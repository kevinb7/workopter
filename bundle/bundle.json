{"escodegen":"// Generated by CommonJS Everywhere 0.9.7\n(function (global) {\n  function require(file, parentModule) {\n    if ({}.hasOwnProperty.call(require.cache, file))\n      return require.cache[file];\n    var resolved = require.resolve(file);\n    if (!resolved)\n      throw new Error('Failed to resolve module ' + file);\n    var module$ = {\n        id: file,\n        require: require,\n        filename: file,\n        exports: {},\n        loaded: false,\n        parent: parentModule,\n        children: []\n      };\n    if (parentModule)\n      parentModule.children.push(module$);\n    var dirname = file.slice(0, file.lastIndexOf('/') + 1);\n    require.cache[file] = module$.exports;\n    resolved.call(module$.exports, module$, module$.exports, dirname, file);\n    module$.loaded = true;\n    return require.cache[file] = module$.exports;\n  }\n  require.modules = {};\n  require.cache = {};\n  require.resolve = function (file) {\n    return {}.hasOwnProperty.call(require.modules, file) ? require.modules[file] : void 0;\n  };\n  require.define = function (file, fn) {\n    require.modules[file] = fn;\n  };\n  var process = function () {\n      var cwd = '/';\n      return {\n        title: 'browser',\n        version: 'v0.10.24',\n        browser: true,\n        env: {},\n        argv: [],\n        nextTick: global.setImmediate || function (fn) {\n          setTimeout(fn, 0);\n        },\n        cwd: function () {\n          return cwd;\n        },\n        chdir: function (dir) {\n          cwd = dir;\n        }\n      };\n    }();\n  require.define('/tools/entry-point.js', function (module, exports, __dirname, __filename) {\n    (function () {\n      'use strict';\n      global.escodegen = require('/escodegen.js', module);\n      escodegen.browser = true;\n    }());\n  });\n  require.define('/escodegen.js', function (module, exports, __dirname, __filename) {\n    (function () {\n      'use strict';\n      var Syntax, Precedence, BinaryPrecedence, SourceNode, estraverse, esutils, isArray, base, indent, json, renumber, hexadecimal, quotes, escapeless, newline, space, parentheses, semicolons, safeConcatenation, directive, extra, parse, sourceMap, FORMAT_MINIFY, FORMAT_DEFAULTS;\n      estraverse = require('/node_modules/estraverse/estraverse.js', module);\n      esutils = require('/node_modules/esutils/lib/utils.js', module);\n      Syntax = {\n        AssignmentExpression: 'AssignmentExpression',\n        ArrayExpression: 'ArrayExpression',\n        ArrayPattern: 'ArrayPattern',\n        ArrowFunctionExpression: 'ArrowFunctionExpression',\n        BlockStatement: 'BlockStatement',\n        BinaryExpression: 'BinaryExpression',\n        BreakStatement: 'BreakStatement',\n        CallExpression: 'CallExpression',\n        CatchClause: 'CatchClause',\n        ClassBody: 'ClassBody',\n        ClassDeclaration: 'ClassDeclaration',\n        ClassExpression: 'ClassExpression',\n        ComprehensionBlock: 'ComprehensionBlock',\n        ComprehensionExpression: 'ComprehensionExpression',\n        ConditionalExpression: 'ConditionalExpression',\n        ContinueStatement: 'ContinueStatement',\n        DirectiveStatement: 'DirectiveStatement',\n        DoWhileStatement: 'DoWhileStatement',\n        DebuggerStatement: 'DebuggerStatement',\n        EmptyStatement: 'EmptyStatement',\n        ExportBatchSpecifier: 'ExportBatchSpecifier',\n        ExportDeclaration: 'ExportDeclaration',\n        ExportSpecifier: 'ExportSpecifier',\n        ExpressionStatement: 'ExpressionStatement',\n        ForStatement: 'ForStatement',\n        ForInStatement: 'ForInStatement',\n        ForOfStatement: 'ForOfStatement',\n        FunctionDeclaration: 'FunctionDeclaration',\n        FunctionExpression: 'FunctionExpression',\n        GeneratorExpression: 'GeneratorExpression',\n        Identifier: 'Identifier',\n        IfStatement: 'IfStatement',\n        ImportDeclaration: 'ImportDeclaration',\n        ImportDefaultSpecifier: 'ImportDefaultSpecifier',\n        ImportNamespaceSpecifier: 'ImportNamespaceSpecifier',\n        ImportSpecifier: 'ImportSpecifier',\n        Literal: 'Literal',\n        LabeledStatement: 'LabeledStatement',\n        LogicalExpression: 'LogicalExpression',\n        MemberExpression: 'MemberExpression',\n        MethodDefinition: 'MethodDefinition',\n        ModuleSpecifier: 'ModuleSpecifier',\n        NewExpression: 'NewExpression',\n        ObjectExpression: 'ObjectExpression',\n        ObjectPattern: 'ObjectPattern',\n        Program: 'Program',\n        Property: 'Property',\n        ReturnStatement: 'ReturnStatement',\n        SequenceExpression: 'SequenceExpression',\n        SpreadElement: 'SpreadElement',\n        SwitchStatement: 'SwitchStatement',\n        SwitchCase: 'SwitchCase',\n        TaggedTemplateExpression: 'TaggedTemplateExpression',\n        TemplateElement: 'TemplateElement',\n        TemplateLiteral: 'TemplateLiteral',\n        ThisExpression: 'ThisExpression',\n        ThrowStatement: 'ThrowStatement',\n        TryStatement: 'TryStatement',\n        UnaryExpression: 'UnaryExpression',\n        UpdateExpression: 'UpdateExpression',\n        VariableDeclaration: 'VariableDeclaration',\n        VariableDeclarator: 'VariableDeclarator',\n        WhileStatement: 'WhileStatement',\n        WithStatement: 'WithStatement',\n        YieldExpression: 'YieldExpression'\n      };\n      function isExpression(node) {\n        return CodeGenerator.Expression.hasOwnProperty(node.type);\n      }\n      function isStatement(node) {\n        return CodeGenerator.Statement.hasOwnProperty(node.type);\n      }\n      Precedence = {\n        Sequence: 0,\n        Yield: 1,\n        Assignment: 1,\n        Conditional: 2,\n        ArrowFunction: 2,\n        LogicalOR: 3,\n        LogicalAND: 4,\n        BitwiseOR: 5,\n        BitwiseXOR: 6,\n        BitwiseAND: 7,\n        Equality: 8,\n        Relational: 9,\n        BitwiseSHIFT: 10,\n        Additive: 11,\n        Multiplicative: 12,\n        Unary: 13,\n        Postfix: 14,\n        Call: 15,\n        New: 16,\n        TaggedTemplate: 17,\n        Member: 18,\n        Primary: 19\n      };\n      BinaryPrecedence = {\n        '||': Precedence.LogicalOR,\n        '&&': Precedence.LogicalAND,\n        '|': Precedence.BitwiseOR,\n        '^': Precedence.BitwiseXOR,\n        '&': Precedence.BitwiseAND,\n        '==': Precedence.Equality,\n        '!=': Precedence.Equality,\n        '===': Precedence.Equality,\n        '!==': Precedence.Equality,\n        'is': Precedence.Equality,\n        'isnt': Precedence.Equality,\n        '<': Precedence.Relational,\n        '>': Precedence.Relational,\n        '<=': Precedence.Relational,\n        '>=': Precedence.Relational,\n        'in': Precedence.Relational,\n        'instanceof': Precedence.Relational,\n        '<<': Precedence.BitwiseSHIFT,\n        '>>': Precedence.BitwiseSHIFT,\n        '>>>': Precedence.BitwiseSHIFT,\n        '+': Precedence.Additive,\n        '-': Precedence.Additive,\n        '*': Precedence.Multiplicative,\n        '%': Precedence.Multiplicative,\n        '/': Precedence.Multiplicative\n      };\n      var F_ALLOW_IN = 1, F_ALLOW_CALL = 1 << 1, F_ALLOW_UNPARATH_NEW = 1 << 2, F_FUNC_BODY = 1 << 3, F_DIRECTIVE_CTX = 1 << 4, F_SEMICOLON_OPT = 1 << 5;\n      var E_FTT = F_ALLOW_CALL | F_ALLOW_UNPARATH_NEW, E_TTF = F_ALLOW_IN | F_ALLOW_CALL, E_TTT = F_ALLOW_IN | F_ALLOW_CALL | F_ALLOW_UNPARATH_NEW, E_TFF = F_ALLOW_IN, E_FFT = F_ALLOW_UNPARATH_NEW, E_TFT = F_ALLOW_IN | F_ALLOW_UNPARATH_NEW;\n      var S_TFFF = F_ALLOW_IN, S_TFFT = F_ALLOW_IN | F_SEMICOLON_OPT, S_FFFF = 0, S_TFTF = F_ALLOW_IN | F_DIRECTIVE_CTX, S_TTFF = F_ALLOW_IN | F_FUNC_BODY;\n      function getDefaultOptions() {\n        return {\n          indent: null,\n          base: null,\n          parse: null,\n          comment: false,\n          format: {\n            indent: {\n              style: '    ',\n              base: 0,\n              adjustMultilineComment: false\n            },\n            newline: '\\n',\n            space: ' ',\n            json: false,\n            renumber: false,\n            hexadecimal: false,\n            quotes: 'single',\n            escapeless: false,\n            compact: false,\n            parentheses: true,\n            semicolons: true,\n            safeConcatenation: false\n          },\n          moz: {\n            comprehensionExpressionStartsWithAssignment: false,\n            starlessGenerator: false\n          },\n          sourceMap: null,\n          sourceMapRoot: null,\n          sourceMapWithCode: false,\n          directive: false,\n          raw: true,\n          verbatim: null\n        };\n      }\n      function stringRepeat(str, num) {\n        var result = '';\n        for (num |= 0; num > 0; num >>>= 1, str += str) {\n          if (num & 1) {\n            result += str;\n          }\n        }\n        return result;\n      }\n      isArray = Array.isArray;\n      if (!isArray) {\n        isArray = function isArray(array) {\n          return Object.prototype.toString.call(array) === '[object Array]';\n        };\n      }\n      function hasLineTerminator(str) {\n        return /[\\r\\n]/g.test(str);\n      }\n      function endsWithLineTerminator(str) {\n        var len = str.length;\n        return len && esutils.code.isLineTerminator(str.charCodeAt(len - 1));\n      }\n      function merge(target, override) {\n        var key;\n        for (key in override) {\n          if (override.hasOwnProperty(key)) {\n            target[key] = override[key];\n          }\n        }\n        return target;\n      }\n      function updateDeeply(target, override) {\n        var key, val;\n        function isHashObject(target) {\n          return typeof target === 'object' && target instanceof Object && !(target instanceof RegExp);\n        }\n        for (key in override) {\n          if (override.hasOwnProperty(key)) {\n            val = override[key];\n            if (isHashObject(val)) {\n              if (isHashObject(target[key])) {\n                updateDeeply(target[key], val);\n              } else {\n                target[key] = updateDeeply({}, val);\n              }\n            } else {\n              target[key] = val;\n            }\n          }\n        }\n        return target;\n      }\n      function generateNumber(value) {\n        var result, point, temp, exponent, pos;\n        if (value !== value) {\n          throw new Error('Numeric literal whose value is NaN');\n        }\n        if (value < 0 || value === 0 && 1 / value < 0) {\n          throw new Error('Numeric literal whose value is negative');\n        }\n        if (value === 1 / 0) {\n          return json ? 'null' : renumber ? '1e400' : '1e+400';\n        }\n        result = '' + value;\n        if (!renumber || result.length < 3) {\n          return result;\n        }\n        point = result.indexOf('.');\n        if (!json && result.charCodeAt(0) === 48 && point === 1) {\n          point = 0;\n          result = result.slice(1);\n        }\n        temp = result;\n        result = result.replace('e+', 'e');\n        exponent = 0;\n        if ((pos = temp.indexOf('e')) > 0) {\n          exponent = +temp.slice(pos + 1);\n          temp = temp.slice(0, pos);\n        }\n        if (point >= 0) {\n          exponent -= temp.length - point - 1;\n          temp = +(temp.slice(0, point) + temp.slice(point + 1)) + '';\n        }\n        pos = 0;\n        while (temp.charCodeAt(temp.length + pos - 1) === 48) {\n          --pos;\n        }\n        if (pos !== 0) {\n          exponent -= pos;\n          temp = temp.slice(0, pos);\n        }\n        if (exponent !== 0) {\n          temp += 'e' + exponent;\n        }\n        if ((temp.length < result.length || hexadecimal && value > 1e12 && Math.floor(value) === value && (temp = '0x' + value.toString(16)).length < result.length) && +temp === value) {\n          result = temp;\n        }\n        return result;\n      }\n      function escapeRegExpCharacter(ch, previousIsBackslash) {\n        if ((ch & ~1) === 8232) {\n          return (previousIsBackslash ? 'u' : '\\\\u') + (ch === 8232 ? '2028' : '2029');\n        } else if (ch === 10 || ch === 13) {\n          return (previousIsBackslash ? '' : '\\\\') + (ch === 10 ? 'n' : 'r');\n        }\n        return String.fromCharCode(ch);\n      }\n      function generateRegExp(reg) {\n        var match, result, flags, i, iz, ch, characterInBrack, previousIsBackslash;\n        result = reg.toString();\n        if (reg.source) {\n          match = result.match(/\\/([^/]*)$/);\n          if (!match) {\n            return result;\n          }\n          flags = match[1];\n          result = '';\n          characterInBrack = false;\n          previousIsBackslash = false;\n          for (i = 0, iz = reg.source.length; i < iz; ++i) {\n            ch = reg.source.charCodeAt(i);\n            if (!previousIsBackslash) {\n              if (characterInBrack) {\n                if (ch === 93) {\n                  characterInBrack = false;\n                }\n              } else {\n                if (ch === 47) {\n                  result += '\\\\';\n                } else if (ch === 91) {\n                  characterInBrack = true;\n                }\n              }\n              result += escapeRegExpCharacter(ch, previousIsBackslash);\n              previousIsBackslash = ch === 92;\n            } else {\n              result += escapeRegExpCharacter(ch, previousIsBackslash);\n              previousIsBackslash = false;\n            }\n          }\n          return '/' + result + '/' + flags;\n        }\n        return result;\n      }\n      function escapeAllowedCharacter(code, next) {\n        var hex;\n        if (code === 8) {\n          return '\\\\b';\n        }\n        if (code === 12) {\n          return '\\\\f';\n        }\n        if (code === 9) {\n          return '\\\\t';\n        }\n        hex = code.toString(16).toUpperCase();\n        if (json || code > 255) {\n          return '\\\\u' + '0000'.slice(hex.length) + hex;\n        } else if (code === 0 && !esutils.code.isDecimalDigit(next)) {\n          return '\\\\0';\n        } else if (code === 11) {\n          return '\\\\x0B';\n        } else {\n          return '\\\\x' + '00'.slice(hex.length) + hex;\n        }\n      }\n      function escapeDisallowedCharacter(code) {\n        if (code === 92) {\n          return '\\\\\\\\';\n        }\n        if (code === 10) {\n          return '\\\\n';\n        }\n        if (code === 13) {\n          return '\\\\r';\n        }\n        if (code === 8232) {\n          return '\\\\u2028';\n        }\n        if (code === 8233) {\n          return '\\\\u2029';\n        }\n        throw new Error('Incorrectly classified character');\n      }\n      function escapeDirective(str) {\n        var i, iz, code, quote;\n        quote = quotes === 'double' ? '\"' : \"'\";\n        for (i = 0, iz = str.length; i < iz; ++i) {\n          code = str.charCodeAt(i);\n          if (code === 39) {\n            quote = '\"';\n            break;\n          } else if (code === 34) {\n            quote = \"'\";\n            break;\n          } else if (code === 92) {\n            ++i;\n          }\n        }\n        return quote + str + quote;\n      }\n      function escapeString(str) {\n        var result = '', i, len, code, singleQuotes = 0, doubleQuotes = 0, single, quote;\n        for (i = 0, len = str.length; i < len; ++i) {\n          code = str.charCodeAt(i);\n          if (code === 39) {\n            ++singleQuotes;\n          } else if (code === 34) {\n            ++doubleQuotes;\n          } else if (code === 47 && json) {\n            result += '\\\\';\n          } else if (esutils.code.isLineTerminator(code) || code === 92) {\n            result += escapeDisallowedCharacter(code);\n            continue;\n          } else if (json && code < 32 || !(json || escapeless || code >= 32 && code <= 126)) {\n            result += escapeAllowedCharacter(code, str.charCodeAt(i + 1));\n            continue;\n          }\n          result += String.fromCharCode(code);\n        }\n        single = !(quotes === 'double' || quotes === 'auto' && doubleQuotes < singleQuotes);\n        quote = single ? \"'\" : '\"';\n        if (!(single ? singleQuotes : doubleQuotes)) {\n          return quote + result + quote;\n        }\n        str = result;\n        result = quote;\n        for (i = 0, len = str.length; i < len; ++i) {\n          code = str.charCodeAt(i);\n          if (code === 39 && single || code === 34 && !single) {\n            result += '\\\\';\n          }\n          result += String.fromCharCode(code);\n        }\n        return result + quote;\n      }\n      function flattenToString(arr) {\n        var i, iz, elem, result = '';\n        for (i = 0, iz = arr.length; i < iz; ++i) {\n          elem = arr[i];\n          result += isArray(elem) ? flattenToString(elem) : elem;\n        }\n        return result;\n      }\n      function toSourceNodeWhenNeeded(generated, node) {\n        if (!sourceMap) {\n          if (isArray(generated)) {\n            return flattenToString(generated);\n          } else {\n            return generated;\n          }\n        }\n        if (node == null) {\n          if (generated instanceof SourceNode) {\n            return generated;\n          } else {\n            node = {};\n          }\n        }\n        if (node.loc == null) {\n          return new SourceNode(null, null, sourceMap, generated, node.name || null);\n        }\n        return new SourceNode(node.loc.start.line, node.loc.start.column, sourceMap === true ? node.loc.source || null : sourceMap, generated, node.name || null);\n      }\n      function noEmptySpace() {\n        return space ? space : ' ';\n      }\n      function join(left, right) {\n        var leftSource, rightSource, leftCharCode, rightCharCode;\n        leftSource = toSourceNodeWhenNeeded(left).toString();\n        if (leftSource.length === 0) {\n          return [right];\n        }\n        rightSource = toSourceNodeWhenNeeded(right).toString();\n        if (rightSource.length === 0) {\n          return [left];\n        }\n        leftCharCode = leftSource.charCodeAt(leftSource.length - 1);\n        rightCharCode = rightSource.charCodeAt(0);\n        if ((leftCharCode === 43 || leftCharCode === 45) && leftCharCode === rightCharCode || esutils.code.isIdentifierPart(leftCharCode) && esutils.code.isIdentifierPart(rightCharCode) || leftCharCode === 47 && rightCharCode === 105) {\n          return [\n            left,\n            noEmptySpace(),\n            right\n          ];\n        } else if (esutils.code.isWhiteSpace(leftCharCode) || esutils.code.isLineTerminator(leftCharCode) || esutils.code.isWhiteSpace(rightCharCode) || esutils.code.isLineTerminator(rightCharCode)) {\n          return [\n            left,\n            right\n          ];\n        }\n        return [\n          left,\n          space,\n          right\n        ];\n      }\n      function addIndent(stmt) {\n        return [\n          base,\n          stmt\n        ];\n      }\n      function withIndent(fn) {\n        var previousBase;\n        previousBase = base;\n        base += indent;\n        fn(base);\n        base = previousBase;\n      }\n      function calculateSpaces(str) {\n        var i;\n        for (i = str.length - 1; i >= 0; --i) {\n          if (esutils.code.isLineTerminator(str.charCodeAt(i))) {\n            break;\n          }\n        }\n        return str.length - 1 - i;\n      }\n      function adjustMultilineComment(value, specialBase) {\n        var array, i, len, line, j, spaces, previousBase, sn;\n        array = value.split(/\\r\\n|[\\r\\n]/);\n        spaces = Number.MAX_VALUE;\n        for (i = 1, len = array.length; i < len; ++i) {\n          line = array[i];\n          j = 0;\n          while (j < line.length && esutils.code.isWhiteSpace(line.charCodeAt(j))) {\n            ++j;\n          }\n          if (spaces > j) {\n            spaces = j;\n          }\n        }\n        if (typeof specialBase !== 'undefined') {\n          previousBase = base;\n          if (array[1][spaces] === '*') {\n            specialBase += ' ';\n          }\n          base = specialBase;\n        } else {\n          if (spaces & 1) {\n            --spaces;\n          }\n          previousBase = base;\n        }\n        for (i = 1, len = array.length; i < len; ++i) {\n          sn = toSourceNodeWhenNeeded(addIndent(array[i].slice(spaces)));\n          array[i] = sourceMap ? sn.join('') : sn;\n        }\n        base = previousBase;\n        return array.join('\\n');\n      }\n      function generateComment(comment, specialBase) {\n        if (comment.type === 'Line') {\n          if (endsWithLineTerminator(comment.value)) {\n            return '//' + comment.value;\n          } else {\n            return '//' + comment.value + '\\n';\n          }\n        }\n        if (extra.format.indent.adjustMultilineComment && /[\\n\\r]/.test(comment.value)) {\n          return adjustMultilineComment('/*' + comment.value + '*/', specialBase);\n        }\n        return '/*' + comment.value + '*/';\n      }\n      function addComments(stmt, result) {\n        var i, len, comment, save, tailingToStatement, specialBase, fragment;\n        if (stmt.leadingComments && stmt.leadingComments.length > 0) {\n          save = result;\n          comment = stmt.leadingComments[0];\n          result = [];\n          if (safeConcatenation && stmt.type === Syntax.Program && stmt.body.length === 0) {\n            result.push('\\n');\n          }\n          result.push(generateComment(comment));\n          if (!endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {\n            result.push('\\n');\n          }\n          for (i = 1, len = stmt.leadingComments.length; i < len; ++i) {\n            comment = stmt.leadingComments[i];\n            fragment = [generateComment(comment)];\n            if (!endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {\n              fragment.push('\\n');\n            }\n            result.push(addIndent(fragment));\n          }\n          result.push(addIndent(save));\n        }\n        if (stmt.trailingComments) {\n          tailingToStatement = !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString());\n          specialBase = stringRepeat(' ', calculateSpaces(toSourceNodeWhenNeeded([\n            base,\n            result,\n            indent\n          ]).toString()));\n          for (i = 0, len = stmt.trailingComments.length; i < len; ++i) {\n            comment = stmt.trailingComments[i];\n            if (tailingToStatement) {\n              if (i === 0) {\n                result = [\n                  result,\n                  indent\n                ];\n              } else {\n                result = [\n                  result,\n                  specialBase\n                ];\n              }\n              result.push(generateComment(comment, specialBase));\n            } else {\n              result = [\n                result,\n                addIndent(generateComment(comment))\n              ];\n            }\n            if (i !== len - 1 && !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {\n              result = [\n                result,\n                '\\n'\n              ];\n            }\n          }\n        }\n        return result;\n      }\n      function parenthesize(text, current, should) {\n        if (current < should) {\n          return [\n            '(',\n            text,\n            ')'\n          ];\n        }\n        return text;\n      }\n      function generateVerbatimString(string) {\n        var i, iz, result;\n        result = string.split(/\\r\\n|\\n/);\n        for (i = 1, iz = result.length; i < iz; i++) {\n          result[i] = newline + base + result[i];\n        }\n        return result;\n      }\n      function generateVerbatim(expr, precedence) {\n        var verbatim, result, prec;\n        verbatim = expr[extra.verbatim];\n        if (typeof verbatim === 'string') {\n          result = parenthesize(generateVerbatimString(verbatim), Precedence.Sequence, precedence);\n        } else {\n          result = generateVerbatimString(verbatim.content);\n          prec = verbatim.precedence != null ? verbatim.precedence : Precedence.Sequence;\n          result = parenthesize(result, prec, precedence);\n        }\n        return toSourceNodeWhenNeeded(result, expr);\n      }\n      function CodeGenerator() {\n      }\n      CodeGenerator.prototype.maybeBlock = function (stmt, flags) {\n        var result, noLeadingComment, that = this;\n        noLeadingComment = !extra.comment || !stmt.leadingComments;\n        if (stmt.type === Syntax.BlockStatement && noLeadingComment) {\n          return [\n            space,\n            this.generateStatement(stmt, flags)\n          ];\n        }\n        if (stmt.type === Syntax.EmptyStatement && noLeadingComment) {\n          return ';';\n        }\n        withIndent(function () {\n          result = [\n            newline,\n            addIndent(that.generateStatement(stmt, flags))\n          ];\n        });\n        return result;\n      };\n      CodeGenerator.prototype.maybeBlockSuffix = function (stmt, result) {\n        var ends = endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString());\n        if (stmt.type === Syntax.BlockStatement && (!extra.comment || !stmt.leadingComments) && !ends) {\n          return [\n            result,\n            space\n          ];\n        }\n        if (ends) {\n          return [\n            result,\n            base\n          ];\n        }\n        return [\n          result,\n          newline,\n          base\n        ];\n      };\n      function generateIdentifier(node) {\n        return toSourceNodeWhenNeeded(node.name, node);\n      }\n      CodeGenerator.prototype.generatePattern = function (node, precedence, flags) {\n        if (node.type === Syntax.Identifier) {\n          return generateIdentifier(node);\n        }\n        return this.generateExpression(node, precedence, flags);\n      };\n      CodeGenerator.prototype.generateFunctionParams = function (node) {\n        var i, iz, result, hasDefault;\n        hasDefault = false;\n        if (node.type === Syntax.ArrowFunctionExpression && !node.rest && (!node.defaults || node.defaults.length === 0) && node.params.length === 1 && node.params[0].type === Syntax.Identifier) {\n          result = [generateIdentifier(node.params[0])];\n        } else {\n          result = ['('];\n          if (node.defaults) {\n            hasDefault = true;\n          }\n          for (i = 0, iz = node.params.length; i < iz; ++i) {\n            if (hasDefault && node.defaults[i]) {\n              result.push(this.generateAssignment(node.params[i], node.defaults[i], '=', Precedence.Assignment, E_TTT));\n            } else {\n              result.push(this.generatePattern(node.params[i], Precedence.Assignment, E_TTT));\n            }\n            if (i + 1 < iz) {\n              result.push(',' + space);\n            }\n          }\n          if (node.rest) {\n            if (node.params.length) {\n              result.push(',' + space);\n            }\n            result.push('...');\n            result.push(generateIdentifier(node.rest));\n          }\n          result.push(')');\n        }\n        return result;\n      };\n      CodeGenerator.prototype.generateFunctionBody = function (node) {\n        var result, expr;\n        result = this.generateFunctionParams(node);\n        if (node.type === Syntax.ArrowFunctionExpression) {\n          result.push(space);\n          result.push('=>');\n        }\n        if (node.expression) {\n          result.push(space);\n          expr = this.generateExpression(node.body, Precedence.Assignment, E_TTT);\n          if (expr.toString().charAt(0) === '{') {\n            expr = [\n              '(',\n              expr,\n              ')'\n            ];\n          }\n          result.push(expr);\n        } else {\n          result.push(this.maybeBlock(node.body, S_TTFF));\n        }\n        return result;\n      };\n      CodeGenerator.prototype.generateIterationForStatement = function (operator, stmt, flags) {\n        var result = ['for' + space + '('], that = this;\n        withIndent(function () {\n          if (stmt.left.type === Syntax.VariableDeclaration) {\n            withIndent(function () {\n              result.push(stmt.left.kind + noEmptySpace());\n              result.push(that.generateStatement(stmt.left.declarations[0], S_FFFF));\n            });\n          } else {\n            result.push(that.generateExpression(stmt.left, Precedence.Call, E_TTT));\n          }\n          result = join(result, operator);\n          result = [\n            join(result, that.generateExpression(stmt.right, Precedence.Sequence, E_TTT)),\n            ')'\n          ];\n        });\n        result.push(this.maybeBlock(stmt.body, flags));\n        return result;\n      };\n      CodeGenerator.prototype.generatePropertyKey = function (expr, computed) {\n        var result = [];\n        if (computed) {\n          result.push('[');\n        }\n        result.push(this.generateExpression(expr, Precedence.Sequence, E_TTT));\n        if (computed) {\n          result.push(']');\n        }\n        return result;\n      };\n      CodeGenerator.prototype.generateAssignment = function (left, right, operator, precedence, flags) {\n        if (Precedence.Assignment < precedence) {\n          flags |= F_ALLOW_IN;\n        }\n        return parenthesize([\n          this.generateExpression(left, Precedence.Call, flags),\n          space + operator + space,\n          this.generateExpression(right, Precedence.Assignment, flags)\n        ], Precedence.Assignment, precedence);\n      };\n      CodeGenerator.prototype.semicolon = function (flags) {\n        if (!semicolons && flags & F_SEMICOLON_OPT) {\n          return '';\n        }\n        return ';';\n      };\n      CodeGenerator.Statement = {\n        BlockStatement: function (stmt, flags) {\n          var result = [\n              '{',\n              newline\n            ], that = this;\n          withIndent(function () {\n            var i, iz, fragment, bodyFlags;\n            bodyFlags = S_TFFF;\n            if (flags & F_FUNC_BODY) {\n              bodyFlags |= F_DIRECTIVE_CTX;\n            }\n            for (i = 0, iz = stmt.body.length; i < iz; ++i) {\n              if (i === iz - 1) {\n                bodyFlags |= F_SEMICOLON_OPT;\n              }\n              fragment = addIndent(that.generateStatement(stmt.body[i], bodyFlags));\n              result.push(fragment);\n              if (!endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {\n                result.push(newline);\n              }\n            }\n          });\n          result.push(addIndent('}'));\n          return result;\n        },\n        BreakStatement: function (stmt, flags) {\n          if (stmt.label) {\n            return 'break ' + stmt.label.name + this.semicolon(flags);\n          }\n          return 'break' + this.semicolon(flags);\n        },\n        ContinueStatement: function (stmt, flags) {\n          if (stmt.label) {\n            return 'continue ' + stmt.label.name + this.semicolon(flags);\n          }\n          return 'continue' + this.semicolon(flags);\n        },\n        ClassBody: function (stmt, flags) {\n          var result = [\n              '{',\n              newline\n            ], that = this;\n          withIndent(function (indent) {\n            var i, iz;\n            for (i = 0, iz = stmt.body.length; i < iz; ++i) {\n              result.push(indent);\n              result.push(that.generateExpression(stmt.body[i], Precedence.Sequence, E_TTT));\n              if (i + 1 < iz) {\n                result.push(newline);\n              }\n            }\n          });\n          if (!endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {\n            result.push(newline);\n          }\n          result.push(base);\n          result.push('}');\n          return result;\n        },\n        ClassDeclaration: function (stmt, flags) {\n          var result, fragment;\n          result = ['class ' + stmt.id.name];\n          if (stmt.superClass) {\n            fragment = join('extends', this.generateExpression(stmt.superClass, Precedence.Assignment, E_TTT));\n            result = join(result, fragment);\n          }\n          result.push(space);\n          result.push(this.generateStatement(stmt.body, S_TFFT));\n          return result;\n        },\n        DirectiveStatement: function (stmt, flags) {\n          if (extra.raw && stmt.raw) {\n            return stmt.raw + this.semicolon(flags);\n          }\n          return escapeDirective(stmt.directive) + this.semicolon(flags);\n        },\n        DoWhileStatement: function (stmt, flags) {\n          var result = join('do', this.maybeBlock(stmt.body, S_TFFF));\n          result = this.maybeBlockSuffix(stmt.body, result);\n          return join(result, [\n            'while' + space + '(',\n            this.generateExpression(stmt.test, Precedence.Sequence, E_TTT),\n            ')' + this.semicolon(flags)\n          ]);\n        },\n        CatchClause: function (stmt, flags) {\n          var result, that = this;\n          withIndent(function () {\n            var guard;\n            result = [\n              'catch' + space + '(',\n              that.generateExpression(stmt.param, Precedence.Sequence, E_TTT),\n              ')'\n            ];\n            if (stmt.guard) {\n              guard = that.generateExpression(stmt.guard, Precedence.Sequence, E_TTT);\n              result.splice(2, 0, ' if ', guard);\n            }\n          });\n          result.push(this.maybeBlock(stmt.body, S_TFFF));\n          return result;\n        },\n        DebuggerStatement: function (stmt, flags) {\n          return 'debugger' + this.semicolon(flags);\n        },\n        EmptyStatement: function (stmt, flags) {\n          return ';';\n        },\n        ExportDeclaration: function (stmt, flags) {\n          var result = ['export'], bodyFlags, that = this;\n          bodyFlags = flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF;\n          if (stmt['default']) {\n            result = join(result, 'default');\n            if (isStatement(stmt.declaration)) {\n              result = join(result, this.generateStatement(stmt.declaration, bodyFlags));\n            } else {\n              result = join(result, this.generateExpression(stmt.declaration, Precedence.Assignment, E_TTT) + this.semicolon(flags));\n            }\n            return result;\n          }\n          if (stmt.declaration) {\n            return join(result, this.generateStatement(stmt.declaration, bodyFlags));\n          }\n          if (stmt.specifiers) {\n            if (stmt.specifiers.length === 0) {\n              result = join(result, '{' + space + '}');\n            } else if (stmt.specifiers[0].type === Syntax.ExportBatchSpecifier) {\n              result = join(result, this.generateExpression(stmt.specifiers[0], Precedence.Sequence, E_TTT));\n            } else {\n              result = join(result, '{');\n              withIndent(function (indent) {\n                var i, iz;\n                result.push(newline);\n                for (i = 0, iz = stmt.specifiers.length; i < iz; ++i) {\n                  result.push(indent);\n                  result.push(that.generateExpression(stmt.specifiers[i], Precedence.Sequence, E_TTT));\n                  if (i + 1 < iz) {\n                    result.push(',' + newline);\n                  }\n                }\n              });\n              if (!endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {\n                result.push(newline);\n              }\n              result.push(base + '}');\n            }\n            if (stmt.source) {\n              result = join(result, [\n                'from' + space,\n                this.generateExpression(stmt.source, Precedence.Sequence, E_TTT),\n                this.semicolon(flags)\n              ]);\n            } else {\n              result.push(this.semicolon(flags));\n            }\n          }\n          return result;\n        },\n        ExpressionStatement: function (stmt, flags) {\n          var result, fragment;\n          result = [this.generateExpression(stmt.expression, Precedence.Sequence, E_TTT)];\n          fragment = toSourceNodeWhenNeeded(result).toString();\n          if (fragment.charAt(0) === '{' || fragment.slice(0, 5) === 'class' && ' {'.indexOf(fragment.charAt(5)) >= 0 || fragment.slice(0, 8) === 'function' && '* ('.indexOf(fragment.charAt(8)) >= 0 || directive && flags & F_DIRECTIVE_CTX && stmt.expression.type === Syntax.Literal && typeof stmt.expression.value === 'string') {\n            result = [\n              '(',\n              result,\n              ')' + this.semicolon(flags)\n            ];\n          } else {\n            result.push(this.semicolon(flags));\n          }\n          return result;\n        },\n        ImportDeclaration: function (stmt, flags) {\n          var result, cursor, that = this;\n          if (stmt.specifiers.length === 0) {\n            return [\n              'import',\n              space,\n              this.generateExpression(stmt.source, Precedence.Sequence, E_TTT),\n              this.semicolon(flags)\n            ];\n          }\n          result = ['import'];\n          cursor = 0;\n          if (stmt.specifiers[cursor].type === Syntax.ImportDefaultSpecifier) {\n            result = join(result, [this.generateExpression(stmt.specifiers[cursor], Precedence.Sequence, E_TTT)]);\n            ++cursor;\n          }\n          if (stmt.specifiers[cursor]) {\n            if (cursor !== 0) {\n              result.push(',');\n            }\n            if (stmt.specifiers[cursor].type === Syntax.ImportNamespaceSpecifier) {\n              result = join(result, [\n                space,\n                this.generateExpression(stmt.specifiers[cursor], Precedence.Sequence, E_TTT)\n              ]);\n            } else {\n              result.push(space + '{');\n              if (stmt.specifiers.length - cursor === 1) {\n                result.push(space);\n                result.push(this.generateExpression(stmt.specifiers[cursor], Precedence.Sequence, E_TTT));\n                result.push(space + '}' + space);\n              } else {\n                withIndent(function (indent) {\n                  var i, iz;\n                  result.push(newline);\n                  for (i = cursor, iz = stmt.specifiers.length; i < iz; ++i) {\n                    result.push(indent);\n                    result.push(that.generateExpression(stmt.specifiers[i], Precedence.Sequence, E_TTT));\n                    if (i + 1 < iz) {\n                      result.push(',' + newline);\n                    }\n                  }\n                });\n                if (!endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {\n                  result.push(newline);\n                }\n                result.push(base + '}' + space);\n              }\n            }\n          }\n          result = join(result, [\n            'from' + space,\n            this.generateExpression(stmt.source, Precedence.Sequence, E_TTT),\n            this.semicolon(flags)\n          ]);\n          return result;\n        },\n        VariableDeclarator: function (stmt, flags) {\n          var itemFlags = flags & F_ALLOW_IN ? E_TTT : E_FTT;\n          if (stmt.init) {\n            return [\n              this.generateExpression(stmt.id, Precedence.Assignment, itemFlags),\n              space,\n              '=',\n              space,\n              this.generateExpression(stmt.init, Precedence.Assignment, itemFlags)\n            ];\n          }\n          return this.generatePattern(stmt.id, Precedence.Assignment, itemFlags);\n        },\n        VariableDeclaration: function (stmt, flags) {\n          var result, i, iz, node, bodyFlags, that = this;\n          result = [stmt.kind];\n          bodyFlags = flags & F_ALLOW_IN ? S_TFFF : S_FFFF;\n          function block() {\n            node = stmt.declarations[0];\n            if (extra.comment && node.leadingComments) {\n              result.push('\\n');\n              result.push(addIndent(that.generateStatement(node, bodyFlags)));\n            } else {\n              result.push(noEmptySpace());\n              result.push(that.generateStatement(node, bodyFlags));\n            }\n            for (i = 1, iz = stmt.declarations.length; i < iz; ++i) {\n              node = stmt.declarations[i];\n              if (extra.comment && node.leadingComments) {\n                result.push(',' + newline);\n                result.push(addIndent(that.generateStatement(node, bodyFlags)));\n              } else {\n                result.push(',' + space);\n                result.push(that.generateStatement(node, bodyFlags));\n              }\n            }\n          }\n          if (stmt.declarations.length > 1) {\n            withIndent(block);\n          } else {\n            block();\n          }\n          result.push(this.semicolon(flags));\n          return result;\n        },\n        ThrowStatement: function (stmt, flags) {\n          return [\n            join('throw', this.generateExpression(stmt.argument, Precedence.Sequence, E_TTT)),\n            this.semicolon(flags)\n          ];\n        },\n        TryStatement: function (stmt, flags) {\n          var result, i, iz, guardedHandlers;\n          result = [\n            'try',\n            this.maybeBlock(stmt.block, S_TFFF)\n          ];\n          result = this.maybeBlockSuffix(stmt.block, result);\n          if (stmt.handlers) {\n            for (i = 0, iz = stmt.handlers.length; i < iz; ++i) {\n              result = join(result, this.generateStatement(stmt.handlers[i], S_TFFF));\n              if (stmt.finalizer || i + 1 !== iz) {\n                result = this.maybeBlockSuffix(stmt.handlers[i].body, result);\n              }\n            }\n          } else {\n            guardedHandlers = stmt.guardedHandlers || [];\n            for (i = 0, iz = guardedHandlers.length; i < iz; ++i) {\n              result = join(result, this.generateStatement(guardedHandlers[i], S_TFFF));\n              if (stmt.finalizer || i + 1 !== iz) {\n                result = this.maybeBlockSuffix(guardedHandlers[i].body, result);\n              }\n            }\n            if (stmt.handler) {\n              if (isArray(stmt.handler)) {\n                for (i = 0, iz = stmt.handler.length; i < iz; ++i) {\n                  result = join(result, this.generateStatement(stmt.handler[i], S_TFFF));\n                  if (stmt.finalizer || i + 1 !== iz) {\n                    result = this.maybeBlockSuffix(stmt.handler[i].body, result);\n                  }\n                }\n              } else {\n                result = join(result, this.generateStatement(stmt.handler, S_TFFF));\n                if (stmt.finalizer) {\n                  result = this.maybeBlockSuffix(stmt.handler.body, result);\n                }\n              }\n            }\n          }\n          if (stmt.finalizer) {\n            result = join(result, [\n              'finally',\n              this.maybeBlock(stmt.finalizer, S_TFFF)\n            ]);\n          }\n          return result;\n        },\n        SwitchStatement: function (stmt, flags) {\n          var result, fragment, i, iz, bodyFlags, that = this;\n          withIndent(function () {\n            result = [\n              'switch' + space + '(',\n              that.generateExpression(stmt.discriminant, Precedence.Sequence, E_TTT),\n              ')' + space + '{' + newline\n            ];\n          });\n          if (stmt.cases) {\n            bodyFlags = S_TFFF;\n            for (i = 0, iz = stmt.cases.length; i < iz; ++i) {\n              if (i === iz - 1) {\n                bodyFlags |= F_SEMICOLON_OPT;\n              }\n              fragment = addIndent(this.generateStatement(stmt.cases[i], bodyFlags));\n              result.push(fragment);\n              if (!endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {\n                result.push(newline);\n              }\n            }\n          }\n          result.push(addIndent('}'));\n          return result;\n        },\n        SwitchCase: function (stmt, flags) {\n          var result, fragment, i, iz, bodyFlags, that = this;\n          withIndent(function () {\n            if (stmt.test) {\n              result = [\n                join('case', that.generateExpression(stmt.test, Precedence.Sequence, E_TTT)),\n                ':'\n              ];\n            } else {\n              result = ['default:'];\n            }\n            i = 0;\n            iz = stmt.consequent.length;\n            if (iz && stmt.consequent[0].type === Syntax.BlockStatement) {\n              fragment = that.maybeBlock(stmt.consequent[0], S_TFFF);\n              result.push(fragment);\n              i = 1;\n            }\n            if (i !== iz && !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {\n              result.push(newline);\n            }\n            bodyFlags = S_TFFF;\n            for (; i < iz; ++i) {\n              if (i === iz - 1 && flags & F_SEMICOLON_OPT) {\n                bodyFlags |= F_SEMICOLON_OPT;\n              }\n              fragment = addIndent(that.generateStatement(stmt.consequent[i], bodyFlags));\n              result.push(fragment);\n              if (i + 1 !== iz && !endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {\n                result.push(newline);\n              }\n            }\n          });\n          return result;\n        },\n        IfStatement: function (stmt, flags) {\n          var result, bodyFlags, semicolonOptional, that = this;\n          withIndent(function () {\n            result = [\n              'if' + space + '(',\n              that.generateExpression(stmt.test, Precedence.Sequence, E_TTT),\n              ')'\n            ];\n          });\n          semicolonOptional = flags & F_SEMICOLON_OPT;\n          bodyFlags = S_TFFF;\n          if (semicolonOptional) {\n            bodyFlags |= F_SEMICOLON_OPT;\n          }\n          if (stmt.alternate) {\n            result.push(this.maybeBlock(stmt.consequent, S_TFFF));\n            result = this.maybeBlockSuffix(stmt.consequent, result);\n            if (stmt.alternate.type === Syntax.IfStatement) {\n              result = join(result, [\n                'else ',\n                this.generateStatement(stmt.alternate, bodyFlags)\n              ]);\n            } else {\n              result = join(result, join('else', this.maybeBlock(stmt.alternate, bodyFlags)));\n            }\n          } else {\n            result.push(this.maybeBlock(stmt.consequent, bodyFlags));\n          }\n          return result;\n        },\n        ForStatement: function (stmt, flags) {\n          var result, that = this;\n          withIndent(function () {\n            result = ['for' + space + '('];\n            if (stmt.init) {\n              if (stmt.init.type === Syntax.VariableDeclaration) {\n                result.push(that.generateStatement(stmt.init, S_FFFF));\n              } else {\n                result.push(that.generateExpression(stmt.init, Precedence.Sequence, E_FTT));\n                result.push(';');\n              }\n            } else {\n              result.push(';');\n            }\n            if (stmt.test) {\n              result.push(space);\n              result.push(that.generateExpression(stmt.test, Precedence.Sequence, E_TTT));\n              result.push(';');\n            } else {\n              result.push(';');\n            }\n            if (stmt.update) {\n              result.push(space);\n              result.push(that.generateExpression(stmt.update, Precedence.Sequence, E_TTT));\n              result.push(')');\n            } else {\n              result.push(')');\n            }\n          });\n          result.push(this.maybeBlock(stmt.body, flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF));\n          return result;\n        },\n        ForInStatement: function (stmt, flags) {\n          return this.generateIterationForStatement('in', stmt, flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF);\n        },\n        ForOfStatement: function (stmt, flags) {\n          return this.generateIterationForStatement('of', stmt, flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF);\n        },\n        LabeledStatement: function (stmt, flags) {\n          return [\n            stmt.label.name + ':',\n            this.maybeBlock(stmt.body, flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF)\n          ];\n        },\n        Program: function (stmt, flags) {\n          var result, fragment, i, iz, bodyFlags;\n          iz = stmt.body.length;\n          result = [safeConcatenation && iz > 0 ? '\\n' : ''];\n          bodyFlags = S_TFTF;\n          for (i = 0; i < iz; ++i) {\n            if (!safeConcatenation && i === iz - 1) {\n              bodyFlags |= F_SEMICOLON_OPT;\n            }\n            fragment = addIndent(this.generateStatement(stmt.body[i], bodyFlags));\n            result.push(fragment);\n            if (i + 1 < iz && !endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {\n              result.push(newline);\n            }\n          }\n          return result;\n        },\n        FunctionDeclaration: function (stmt, flags) {\n          var isGenerator = stmt.generator && !extra.moz.starlessGenerator;\n          return [\n            isGenerator ? 'function*' : 'function',\n            isGenerator ? space : noEmptySpace(),\n            generateIdentifier(stmt.id),\n            this.generateFunctionBody(stmt)\n          ];\n        },\n        ReturnStatement: function (stmt, flags) {\n          if (stmt.argument) {\n            return [\n              join('return', this.generateExpression(stmt.argument, Precedence.Sequence, E_TTT)),\n              this.semicolon(flags)\n            ];\n          }\n          return ['return' + this.semicolon(flags)];\n        },\n        WhileStatement: function (stmt, flags) {\n          var result, that = this;\n          withIndent(function () {\n            result = [\n              'while' + space + '(',\n              that.generateExpression(stmt.test, Precedence.Sequence, E_TTT),\n              ')'\n            ];\n          });\n          result.push(this.maybeBlock(stmt.body, flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF));\n          return result;\n        },\n        WithStatement: function (stmt, flags) {\n          var result, that = this;\n          withIndent(function () {\n            result = [\n              'with' + space + '(',\n              that.generateExpression(stmt.object, Precedence.Sequence, E_TTT),\n              ')'\n            ];\n          });\n          result.push(this.maybeBlock(stmt.body, flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF));\n          return result;\n        }\n      };\n      merge(CodeGenerator.prototype, CodeGenerator.Statement);\n      CodeGenerator.Expression = {\n        SequenceExpression: function (expr, precedence, flags) {\n          var result, i, iz;\n          if (Precedence.Sequence < precedence) {\n            flags |= F_ALLOW_IN;\n          }\n          result = [];\n          for (i = 0, iz = expr.expressions.length; i < iz; ++i) {\n            result.push(this.generateExpression(expr.expressions[i], Precedence.Assignment, flags));\n            if (i + 1 < iz) {\n              result.push(',' + space);\n            }\n          }\n          return parenthesize(result, Precedence.Sequence, precedence);\n        },\n        AssignmentExpression: function (expr, precedence, flags) {\n          return this.generateAssignment(expr.left, expr.right, expr.operator, precedence, flags);\n        },\n        ArrowFunctionExpression: function (expr, precedence, flags) {\n          return parenthesize(this.generateFunctionBody(expr), Precedence.ArrowFunction, precedence);\n        },\n        ConditionalExpression: function (expr, precedence, flags) {\n          if (Precedence.Conditional < precedence) {\n            flags |= F_ALLOW_IN;\n          }\n          return parenthesize([\n            this.generateExpression(expr.test, Precedence.LogicalOR, flags),\n            space + '?' + space,\n            this.generateExpression(expr.consequent, Precedence.Assignment, flags),\n            space + ':' + space,\n            this.generateExpression(expr.alternate, Precedence.Assignment, flags)\n          ], Precedence.Conditional, precedence);\n        },\n        LogicalExpression: function (expr, precedence, flags) {\n          return this.BinaryExpression(expr, precedence, flags);\n        },\n        BinaryExpression: function (expr, precedence, flags) {\n          var result, currentPrecedence, fragment, leftSource;\n          currentPrecedence = BinaryPrecedence[expr.operator];\n          if (currentPrecedence < precedence) {\n            flags |= F_ALLOW_IN;\n          }\n          fragment = this.generateExpression(expr.left, currentPrecedence, flags);\n          leftSource = fragment.toString();\n          if (leftSource.charCodeAt(leftSource.length - 1) === 47 && esutils.code.isIdentifierPart(expr.operator.charCodeAt(0))) {\n            result = [\n              fragment,\n              noEmptySpace(),\n              expr.operator\n            ];\n          } else {\n            result = join(fragment, expr.operator);\n          }\n          fragment = this.generateExpression(expr.right, currentPrecedence + 1, flags);\n          if (expr.operator === '/' && fragment.toString().charAt(0) === '/' || expr.operator.slice(-1) === '<' && fragment.toString().slice(0, 3) === '!--') {\n            result.push(noEmptySpace());\n            result.push(fragment);\n          } else {\n            result = join(result, fragment);\n          }\n          if (expr.operator === 'in' && !(flags & F_ALLOW_IN)) {\n            return [\n              '(',\n              result,\n              ')'\n            ];\n          }\n          return parenthesize(result, currentPrecedence, precedence);\n        },\n        CallExpression: function (expr, precedence, flags) {\n          var result, i, iz;\n          result = [this.generateExpression(expr.callee, Precedence.Call, E_TTF)];\n          result.push('(');\n          for (i = 0, iz = expr['arguments'].length; i < iz; ++i) {\n            result.push(this.generateExpression(expr['arguments'][i], Precedence.Assignment, E_TTT));\n            if (i + 1 < iz) {\n              result.push(',' + space);\n            }\n          }\n          result.push(')');\n          if (!(flags & F_ALLOW_CALL)) {\n            return [\n              '(',\n              result,\n              ')'\n            ];\n          }\n          return parenthesize(result, Precedence.Call, precedence);\n        },\n        NewExpression: function (expr, precedence, flags) {\n          var result, length, i, iz, itemFlags;\n          length = expr['arguments'].length;\n          itemFlags = flags & F_ALLOW_UNPARATH_NEW && !parentheses && length === 0 ? E_TFT : E_TFF;\n          result = join('new', this.generateExpression(expr.callee, Precedence.New, itemFlags));\n          if (!(flags & F_ALLOW_UNPARATH_NEW) || parentheses || length > 0) {\n            result.push('(');\n            for (i = 0, iz = length; i < iz; ++i) {\n              result.push(this.generateExpression(expr['arguments'][i], Precedence.Assignment, E_TTT));\n              if (i + 1 < iz) {\n                result.push(',' + space);\n              }\n            }\n            result.push(')');\n          }\n          return parenthesize(result, Precedence.New, precedence);\n        },\n        MemberExpression: function (expr, precedence, flags) {\n          var result, fragment;\n          result = [this.generateExpression(expr.object, Precedence.Call, flags & F_ALLOW_CALL ? E_TTF : E_TFF)];\n          if (expr.computed) {\n            result.push('[');\n            result.push(this.generateExpression(expr.property, Precedence.Sequence, flags & F_ALLOW_CALL ? E_TTT : E_TFT));\n            result.push(']');\n          } else {\n            if (expr.object.type === Syntax.Literal && typeof expr.object.value === 'number') {\n              fragment = toSourceNodeWhenNeeded(result).toString();\n              if (fragment.indexOf('.') < 0 && !/[eExX]/.test(fragment) && esutils.code.isDecimalDigit(fragment.charCodeAt(fragment.length - 1)) && !(fragment.length >= 2 && fragment.charCodeAt(0) === 48)) {\n                result.push('.');\n              }\n            }\n            result.push('.');\n            result.push(generateIdentifier(expr.property));\n          }\n          return parenthesize(result, Precedence.Member, precedence);\n        },\n        UnaryExpression: function (expr, precedence, flags) {\n          var result, fragment, rightCharCode, leftSource, leftCharCode;\n          fragment = this.generateExpression(expr.argument, Precedence.Unary, E_TTT);\n          if (space === '') {\n            result = join(expr.operator, fragment);\n          } else {\n            result = [expr.operator];\n            if (expr.operator.length > 2) {\n              result = join(result, fragment);\n            } else {\n              leftSource = toSourceNodeWhenNeeded(result).toString();\n              leftCharCode = leftSource.charCodeAt(leftSource.length - 1);\n              rightCharCode = fragment.toString().charCodeAt(0);\n              if ((leftCharCode === 43 || leftCharCode === 45) && leftCharCode === rightCharCode || esutils.code.isIdentifierPart(leftCharCode) && esutils.code.isIdentifierPart(rightCharCode)) {\n                result.push(noEmptySpace());\n                result.push(fragment);\n              } else {\n                result.push(fragment);\n              }\n            }\n          }\n          return parenthesize(result, Precedence.Unary, precedence);\n        },\n        YieldExpression: function (expr, precedence, flags) {\n          var result;\n          if (expr.delegate) {\n            result = 'yield*';\n          } else {\n            result = 'yield';\n          }\n          if (expr.argument) {\n            result = join(result, this.generateExpression(expr.argument, Precedence.Yield, E_TTT));\n          }\n          return parenthesize(result, Precedence.Yield, Infinity);\n        },\n        UpdateExpression: function (expr, precedence, flags) {\n          if (expr.prefix) {\n            return parenthesize([\n              expr.operator,\n              this.generateExpression(expr.argument, Precedence.Unary, E_TTT)\n            ], Precedence.Unary, precedence);\n          }\n          return parenthesize([\n            this.generateExpression(expr.argument, Precedence.Postfix, E_TTT),\n            expr.operator\n          ], Precedence.Postfix, precedence);\n        },\n        FunctionExpression: function (expr, precedence, flags) {\n          var result, isGenerator;\n          isGenerator = expr.generator && !extra.moz.starlessGenerator;\n          result = isGenerator ? 'function*' : 'function';\n          if (expr.id) {\n            return [\n              result,\n              isGenerator ? space : noEmptySpace(),\n              generateIdentifier(expr.id),\n              this.generateFunctionBody(expr)\n            ];\n          }\n          return [\n            result + space,\n            this.generateFunctionBody(expr)\n          ];\n        },\n        ExportBatchSpecifier: function (expr, precedence, flags) {\n          return '*';\n        },\n        ArrayPattern: function (expr, precedence, flags) {\n          return this.ArrayExpression(expr, precedence, flags);\n        },\n        ArrayExpression: function (expr, precedence, flags) {\n          var result, multiline, that = this;\n          if (!expr.elements.length) {\n            return '[]';\n          }\n          multiline = expr.elements.length > 1;\n          result = [\n            '[',\n            multiline ? newline : ''\n          ];\n          withIndent(function (indent) {\n            var i, iz;\n            for (i = 0, iz = expr.elements.length; i < iz; ++i) {\n              if (!expr.elements[i]) {\n                if (multiline) {\n                  result.push(indent);\n                }\n                if (i + 1 === iz) {\n                  result.push(',');\n                }\n              } else {\n                result.push(multiline ? indent : '');\n                result.push(that.generateExpression(expr.elements[i], Precedence.Assignment, E_TTT));\n              }\n              if (i + 1 < iz) {\n                result.push(',' + (multiline ? newline : space));\n              }\n            }\n          });\n          if (multiline && !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {\n            result.push(newline);\n          }\n          result.push(multiline ? base : '');\n          result.push(']');\n          return result;\n        },\n        ClassExpression: function (expr, precedence, flags) {\n          var result, fragment;\n          result = ['class'];\n          if (expr.id) {\n            result = join(result, this.generateExpression(expr.id, Precedence.Sequence, E_TTT));\n          }\n          if (expr.superClass) {\n            fragment = join('extends', this.generateExpression(expr.superClass, Precedence.Assignment, E_TTT));\n            result = join(result, fragment);\n          }\n          result.push(space);\n          result.push(this.generateStatement(expr.body, S_TFFT));\n          return result;\n        },\n        MethodDefinition: function (expr, precedence, flags) {\n          var result, fragment;\n          if (expr['static']) {\n            result = ['static' + space];\n          } else {\n            result = [];\n          }\n          if (expr.kind === 'get' || expr.kind === 'set') {\n            result = join(result, [\n              join(expr.kind, this.generatePropertyKey(expr.key, expr.computed)),\n              this.generateFunctionBody(expr.value)\n            ]);\n          } else {\n            fragment = [\n              this.generatePropertyKey(expr.key, expr.computed),\n              this.generateFunctionBody(expr.value)\n            ];\n            if (expr.value.generator) {\n              result.push('*');\n              result.push(fragment);\n            } else {\n              result = join(result, fragment);\n            }\n          }\n          return result;\n        },\n        Property: function (expr, precedence, flags) {\n          var result;\n          if (expr.kind === 'get' || expr.kind === 'set') {\n            return [\n              expr.kind,\n              noEmptySpace(),\n              this.generatePropertyKey(expr.key, expr.computed),\n              this.generateFunctionBody(expr.value)\n            ];\n          }\n          if (expr.shorthand) {\n            return this.generatePropertyKey(expr.key, expr.computed);\n          }\n          if (expr.method) {\n            result = [];\n            if (expr.value.generator) {\n              result.push('*');\n            }\n            result.push(this.generatePropertyKey(expr.key, expr.computed));\n            result.push(this.generateFunctionBody(expr.value));\n            return result;\n          }\n          return [\n            this.generatePropertyKey(expr.key, expr.computed),\n            ':' + space,\n            this.generateExpression(expr.value, Precedence.Assignment, E_TTT)\n          ];\n        },\n        ObjectExpression: function (expr, precedence, flags) {\n          var multiline, result, fragment, that = this;\n          if (!expr.properties.length) {\n            return '{}';\n          }\n          multiline = expr.properties.length > 1;\n          withIndent(function () {\n            fragment = that.generateExpression(expr.properties[0], Precedence.Sequence, E_TTT);\n          });\n          if (!multiline) {\n            if (!hasLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {\n              return [\n                '{',\n                space,\n                fragment,\n                space,\n                '}'\n              ];\n            }\n          }\n          withIndent(function (indent) {\n            var i, iz;\n            result = [\n              '{',\n              newline,\n              indent,\n              fragment\n            ];\n            if (multiline) {\n              result.push(',' + newline);\n              for (i = 1, iz = expr.properties.length; i < iz; ++i) {\n                result.push(indent);\n                result.push(that.generateExpression(expr.properties[i], Precedence.Sequence, E_TTT));\n                if (i + 1 < iz) {\n                  result.push(',' + newline);\n                }\n              }\n            }\n          });\n          if (!endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {\n            result.push(newline);\n          }\n          result.push(base);\n          result.push('}');\n          return result;\n        },\n        ObjectPattern: function (expr, precedence, flags) {\n          var result, i, iz, multiline, property, that = this;\n          if (!expr.properties.length) {\n            return '{}';\n          }\n          multiline = false;\n          if (expr.properties.length === 1) {\n            property = expr.properties[0];\n            if (property.value.type !== Syntax.Identifier) {\n              multiline = true;\n            }\n          } else {\n            for (i = 0, iz = expr.properties.length; i < iz; ++i) {\n              property = expr.properties[i];\n              if (!property.shorthand) {\n                multiline = true;\n                break;\n              }\n            }\n          }\n          result = [\n            '{',\n            multiline ? newline : ''\n          ];\n          withIndent(function (indent) {\n            var i, iz;\n            for (i = 0, iz = expr.properties.length; i < iz; ++i) {\n              result.push(multiline ? indent : '');\n              result.push(that.generateExpression(expr.properties[i], Precedence.Sequence, E_TTT));\n              if (i + 1 < iz) {\n                result.push(',' + (multiline ? newline : space));\n              }\n            }\n          });\n          if (multiline && !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {\n            result.push(newline);\n          }\n          result.push(multiline ? base : '');\n          result.push('}');\n          return result;\n        },\n        ThisExpression: function (expr, precedence, flags) {\n          return 'this';\n        },\n        Identifier: function (expr, precedence, flags) {\n          return generateIdentifier(expr);\n        },\n        ImportDefaultSpecifier: function (expr, precedence, flags) {\n          return generateIdentifier(expr.id);\n        },\n        ImportNamespaceSpecifier: function (expr, precedence, flags) {\n          var result = ['*'];\n          if (expr.id) {\n            result.push(space + 'as' + noEmptySpace() + generateIdentifier(expr.id));\n          }\n          return result;\n        },\n        ImportSpecifier: function (expr, precedence, flags) {\n          return this.ExportSpecifier(expr, precedence, flags);\n        },\n        ExportSpecifier: function (expr, precedence, flags) {\n          var result = [expr.id.name];\n          if (expr.name) {\n            result.push(noEmptySpace() + 'as' + noEmptySpace() + generateIdentifier(expr.name));\n          }\n          return result;\n        },\n        Literal: function (expr, precedence, flags) {\n          var raw;\n          if (expr.hasOwnProperty('raw') && parse && extra.raw) {\n            try {\n              raw = parse(expr.raw).body[0].expression;\n              if (raw.type === Syntax.Literal) {\n                if (raw.value === expr.value) {\n                  return expr.raw;\n                }\n              }\n            } catch (e) {\n            }\n          }\n          if (expr.value === null) {\n            return 'null';\n          }\n          if (typeof expr.value === 'string') {\n            return escapeString(expr.value);\n          }\n          if (typeof expr.value === 'number') {\n            return generateNumber(expr.value);\n          }\n          if (typeof expr.value === 'boolean') {\n            return expr.value ? 'true' : 'false';\n          }\n          return generateRegExp(expr.value);\n        },\n        GeneratorExpression: function (expr, precedence, flags) {\n          return this.ComprehensionExpression(expr, precedence, flags);\n        },\n        ComprehensionExpression: function (expr, precedence, flags) {\n          var result, i, iz, fragment, that = this;\n          result = expr.type === Syntax.GeneratorExpression ? ['('] : ['['];\n          if (extra.moz.comprehensionExpressionStartsWithAssignment) {\n            fragment = this.generateExpression(expr.body, Precedence.Assignment, E_TTT);\n            result.push(fragment);\n          }\n          if (expr.blocks) {\n            withIndent(function () {\n              for (i = 0, iz = expr.blocks.length; i < iz; ++i) {\n                fragment = that.generateExpression(expr.blocks[i], Precedence.Sequence, E_TTT);\n                if (i > 0 || extra.moz.comprehensionExpressionStartsWithAssignment) {\n                  result = join(result, fragment);\n                } else {\n                  result.push(fragment);\n                }\n              }\n            });\n          }\n          if (expr.filter) {\n            result = join(result, 'if' + space);\n            fragment = this.generateExpression(expr.filter, Precedence.Sequence, E_TTT);\n            result = join(result, [\n              '(',\n              fragment,\n              ')'\n            ]);\n          }\n          if (!extra.moz.comprehensionExpressionStartsWithAssignment) {\n            fragment = this.generateExpression(expr.body, Precedence.Assignment, E_TTT);\n            result = join(result, fragment);\n          }\n          result.push(expr.type === Syntax.GeneratorExpression ? ')' : ']');\n          return result;\n        },\n        ComprehensionBlock: function (expr, precedence, flags) {\n          var fragment;\n          if (expr.left.type === Syntax.VariableDeclaration) {\n            fragment = [\n              expr.left.kind,\n              noEmptySpace(),\n              this.generateStatement(expr.left.declarations[0], S_FFFF)\n            ];\n          } else {\n            fragment = this.generateExpression(expr.left, Precedence.Call, E_TTT);\n          }\n          fragment = join(fragment, expr.of ? 'of' : 'in');\n          fragment = join(fragment, this.generateExpression(expr.right, Precedence.Sequence, E_TTT));\n          return [\n            'for' + space + '(',\n            fragment,\n            ')'\n          ];\n        },\n        SpreadElement: function (expr, precedence, flags) {\n          return [\n            '...',\n            this.generateExpression(expr.argument, Precedence.Assignment, E_TTT)\n          ];\n        },\n        TaggedTemplateExpression: function (expr, precedence, flags) {\n          var itemFlags = E_TTF;\n          if (!(flags & F_ALLOW_CALL)) {\n            itemFlags = E_TFF;\n          }\n          var result = [\n              this.generateExpression(expr.tag, Precedence.Call, itemFlags),\n              this.generateExpression(expr.quasi, Precedence.Primary, E_FFT)\n            ];\n          return parenthesize(result, Precedence.TaggedTemplate, precedence);\n        },\n        TemplateElement: function (expr, precedence, flags) {\n          return expr.value.raw;\n        },\n        TemplateLiteral: function (expr, precedence, flags) {\n          var result, i, iz;\n          result = ['`'];\n          for (i = 0, iz = expr.quasis.length; i < iz; ++i) {\n            result.push(this.generateExpression(expr.quasis[i], Precedence.Primary, E_TTT));\n            if (i + 1 < iz) {\n              result.push('${' + space);\n              result.push(this.generateExpression(expr.expressions[i], Precedence.Sequence, E_TTT));\n              result.push(space + '}');\n            }\n          }\n          result.push('`');\n          return result;\n        },\n        ModuleSpecifier: function (expr, precedence, flags) {\n          return this.Literal(expr, precedence, flags);\n        }\n      };\n      merge(CodeGenerator.prototype, CodeGenerator.Expression);\n      CodeGenerator.prototype.generateExpression = function (expr, precedence, flags) {\n        var result, type;\n        type = expr.type || Syntax.Property;\n        if (extra.verbatim && expr.hasOwnProperty(extra.verbatim)) {\n          return generateVerbatim(expr, precedence);\n        }\n        result = this[type](expr, precedence, flags);\n        if (extra.comment) {\n          result = addComments(expr, result);\n        }\n        return toSourceNodeWhenNeeded(result, expr);\n      };\n      CodeGenerator.prototype.generateStatement = function (stmt, flags) {\n        var result, fragment;\n        result = this[stmt.type](stmt, flags);\n        if (extra.comment) {\n          result = addComments(stmt, result);\n        }\n        fragment = toSourceNodeWhenNeeded(result).toString();\n        if (stmt.type === Syntax.Program && !safeConcatenation && newline === '' && fragment.charAt(fragment.length - 1) === '\\n') {\n          result = sourceMap ? toSourceNodeWhenNeeded(result).replaceRight(/\\s+$/, '') : fragment.replace(/\\s+$/, '');\n        }\n        return toSourceNodeWhenNeeded(result, stmt);\n      };\n      function generateInternal(node) {\n        var codegen;\n        codegen = new CodeGenerator;\n        if (isStatement(node)) {\n          return codegen.generateStatement(node, S_TFFF);\n        }\n        if (isExpression(node)) {\n          return codegen.generateExpression(node, Precedence.Sequence, E_TTT);\n        }\n        throw new Error('Unknown node type: ' + node.type);\n      }\n      function generate(node, options) {\n        var defaultOptions = getDefaultOptions(), result, pair;\n        if (options != null) {\n          if (typeof options.indent === 'string') {\n            defaultOptions.format.indent.style = options.indent;\n          }\n          if (typeof options.base === 'number') {\n            defaultOptions.format.indent.base = options.base;\n          }\n          options = updateDeeply(defaultOptions, options);\n          indent = options.format.indent.style;\n          if (typeof options.base === 'string') {\n            base = options.base;\n          } else {\n            base = stringRepeat(indent, options.format.indent.base);\n          }\n        } else {\n          options = defaultOptions;\n          indent = options.format.indent.style;\n          base = stringRepeat(indent, options.format.indent.base);\n        }\n        json = options.format.json;\n        renumber = options.format.renumber;\n        hexadecimal = json ? false : options.format.hexadecimal;\n        quotes = json ? 'double' : options.format.quotes;\n        escapeless = options.format.escapeless;\n        newline = options.format.newline;\n        space = options.format.space;\n        if (options.format.compact) {\n          newline = space = indent = base = '';\n        }\n        parentheses = options.format.parentheses;\n        semicolons = options.format.semicolons;\n        safeConcatenation = options.format.safeConcatenation;\n        directive = options.directive;\n        parse = json ? null : options.parse;\n        sourceMap = options.sourceMap;\n        extra = options;\n        if (sourceMap) {\n          if (!exports.browser) {\n            SourceNode = require('/node_modules/source-map/lib/source-map.js', module).SourceNode;\n          } else {\n            SourceNode = global.sourceMap.SourceNode;\n          }\n        }\n        result = generateInternal(node);\n        if (!sourceMap) {\n          pair = {\n            code: result.toString(),\n            map: null\n          };\n          return options.sourceMapWithCode ? pair : pair.code;\n        }\n        pair = result.toStringWithSourceMap({\n          file: options.file,\n          sourceRoot: options.sourceMapRoot\n        });\n        if (options.sourceContent) {\n          pair.map.setSourceContent(options.sourceMap, options.sourceContent);\n        }\n        if (options.sourceMapWithCode) {\n          return pair;\n        }\n        return pair.map.toString();\n      }\n      FORMAT_MINIFY = {\n        indent: {\n          style: '',\n          base: 0\n        },\n        renumber: true,\n        hexadecimal: true,\n        quotes: 'auto',\n        escapeless: true,\n        compact: true,\n        parentheses: false,\n        semicolons: false\n      };\n      FORMAT_DEFAULTS = getDefaultOptions().format;\n      exports.version = require('/package.json', module).version;\n      exports.generate = generate;\n      exports.attachComments = estraverse.attachComments;\n      exports.Precedence = updateDeeply({}, Precedence);\n      exports.browser = false;\n      exports.FORMAT_MINIFY = FORMAT_MINIFY;\n      exports.FORMAT_DEFAULTS = FORMAT_DEFAULTS;\n    }());\n  });\n  require.define('/package.json', function (module, exports, __dirname, __filename) {\n    module.exports = {\n      'name': 'escodegen',\n      'description': 'ECMAScript code generator',\n      'homepage': 'http://github.com/estools/escodegen',\n      'main': 'escodegen.js',\n      'bin': {\n        'esgenerate': './bin/esgenerate.js',\n        'escodegen': './bin/escodegen.js'\n      },\n      'files': [\n        'LICENSE.BSD',\n        'LICENSE.source-map',\n        'README.md',\n        'bin',\n        'escodegen.js',\n        'package.json'\n      ],\n      'version': '1.4.4-dev',\n      'engines': { 'node': '>=0.10.0' },\n      'maintainers': [{\n          'name': 'Yusuke Suzuki',\n          'email': 'utatane.tea@gmail.com',\n          'web': 'http://github.com/Constellation'\n        }],\n      'repository': {\n        'type': 'git',\n        'url': 'http://github.com/estools/escodegen.git'\n      },\n      'dependencies': {\n        'estraverse': '^1.9.0',\n        'esutils': '^1.1.6',\n        'esprima': '^1.2.2',\n        'optionator': '^0.5.0'\n      },\n      'optionalDependencies': { 'source-map': '~0.1.40' },\n      'devDependencies': {\n        'bluebird': '^2.3.11',\n        'bower-registry-client': '^0.2.1',\n        'browserify': '^7.0.1',\n        'chai': '^1.10.0',\n        'commonjs-everywhere': '^0.9.7',\n        'esprima-moz': '*',\n        'gulp': '^3.8.10',\n        'gulp-eslint': '^0.2.0',\n        'gulp-mocha': '^2.0.0',\n        'semver': '^4.1.0'\n      },\n      'licenses': [{\n          'type': 'BSD',\n          'url': 'http://github.com/estools/escodegen/raw/master/LICENSE.BSD'\n        }],\n      'scripts': {\n        'test': 'gulp travis',\n        'unit-test': 'gulp test',\n        'lint': 'gulp lint',\n        'release': 'node tools/release.js',\n        'build-min': './node_modules/.bin/cjsify -ma path: tools/entry-point.js > escodegen.browser.min.js',\n        'build': './node_modules/.bin/cjsify -a path: tools/entry-point.js > escodegen.browser.js'\n      }\n    };\n  });\n  require.define('/node_modules/source-map/lib/source-map.js', function (module, exports, __dirname, __filename) {\n    exports.SourceMapGenerator = require('/node_modules/source-map/lib/source-map/source-map-generator.js', module).SourceMapGenerator;\n    exports.SourceMapConsumer = require('/node_modules/source-map/lib/source-map/source-map-consumer.js', module).SourceMapConsumer;\n    exports.SourceNode = require('/node_modules/source-map/lib/source-map/source-node.js', module).SourceNode;\n  });\n  require.define('/node_modules/source-map/lib/source-map/source-node.js', function (module, exports, __dirname, __filename) {\n    if (typeof define !== 'function') {\n      var define = require('/node_modules/source-map/node_modules/amdefine/amdefine.js', module)(module, require);\n    }\n    define(function (require, exports, module) {\n      var SourceMapGenerator = require('/node_modules/source-map/lib/source-map/source-map-generator.js', module).SourceMapGenerator;\n      var util = require('/node_modules/source-map/lib/source-map/util.js', module);\n      var REGEX_NEWLINE = /(\\r?\\n)/;\n      var REGEX_CHARACTER = /\\r\\n|[\\s\\S]/g;\n      function SourceNode(aLine, aColumn, aSource, aChunks, aName) {\n        this.children = [];\n        this.sourceContents = {};\n        this.line = aLine == null ? null : aLine;\n        this.column = aColumn == null ? null : aColumn;\n        this.source = aSource == null ? null : aSource;\n        this.name = aName == null ? null : aName;\n        if (aChunks != null)\n          this.add(aChunks);\n      }\n      SourceNode.fromStringWithSourceMap = function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {\n        var node = new SourceNode;\n        var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);\n        var shiftNextLine = function () {\n          var lineContents = remainingLines.shift();\n          var newLine = remainingLines.shift() || '';\n          return lineContents + newLine;\n        };\n        var lastGeneratedLine = 1, lastGeneratedColumn = 0;\n        var lastMapping = null;\n        aSourceMapConsumer.eachMapping(function (mapping) {\n          if (lastMapping !== null) {\n            if (lastGeneratedLine < mapping.generatedLine) {\n              var code = '';\n              addMappingWithCode(lastMapping, shiftNextLine());\n              lastGeneratedLine++;\n              lastGeneratedColumn = 0;\n            } else {\n              var nextLine = remainingLines[0];\n              var code = nextLine.substr(0, mapping.generatedColumn - lastGeneratedColumn);\n              remainingLines[0] = nextLine.substr(mapping.generatedColumn - lastGeneratedColumn);\n              lastGeneratedColumn = mapping.generatedColumn;\n              addMappingWithCode(lastMapping, code);\n              lastMapping = mapping;\n              return;\n            }\n          }\n          while (lastGeneratedLine < mapping.generatedLine) {\n            node.add(shiftNextLine());\n            lastGeneratedLine++;\n          }\n          if (lastGeneratedColumn < mapping.generatedColumn) {\n            var nextLine = remainingLines[0];\n            node.add(nextLine.substr(0, mapping.generatedColumn));\n            remainingLines[0] = nextLine.substr(mapping.generatedColumn);\n            lastGeneratedColumn = mapping.generatedColumn;\n          }\n          lastMapping = mapping;\n        }, this);\n        if (remainingLines.length > 0) {\n          if (lastMapping) {\n            addMappingWithCode(lastMapping, shiftNextLine());\n          }\n          node.add(remainingLines.join(''));\n        }\n        aSourceMapConsumer.sources.forEach(function (sourceFile) {\n          var content = aSourceMapConsumer.sourceContentFor(sourceFile);\n          if (content != null) {\n            if (aRelativePath != null) {\n              sourceFile = util.join(aRelativePath, sourceFile);\n            }\n            node.setSourceContent(sourceFile, content);\n          }\n        });\n        return node;\n        function addMappingWithCode(mapping, code) {\n          if (mapping === null || mapping.source === undefined) {\n            node.add(code);\n          } else {\n            var source = aRelativePath ? util.join(aRelativePath, mapping.source) : mapping.source;\n            node.add(new SourceNode(mapping.originalLine, mapping.originalColumn, source, code, mapping.name));\n          }\n        }\n      };\n      SourceNode.prototype.add = function SourceNode_add(aChunk) {\n        if (Array.isArray(aChunk)) {\n          aChunk.forEach(function (chunk) {\n            this.add(chunk);\n          }, this);\n        } else if (aChunk instanceof SourceNode || typeof aChunk === 'string') {\n          if (aChunk) {\n            this.children.push(aChunk);\n          }\n        } else {\n          throw new TypeError('Expected a SourceNode, string, or an array of SourceNodes and strings. Got ' + aChunk);\n        }\n        return this;\n      };\n      SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {\n        if (Array.isArray(aChunk)) {\n          for (var i = aChunk.length - 1; i >= 0; i--) {\n            this.prepend(aChunk[i]);\n          }\n        } else if (aChunk instanceof SourceNode || typeof aChunk === 'string') {\n          this.children.unshift(aChunk);\n        } else {\n          throw new TypeError('Expected a SourceNode, string, or an array of SourceNodes and strings. Got ' + aChunk);\n        }\n        return this;\n      };\n      SourceNode.prototype.walk = function SourceNode_walk(aFn) {\n        var chunk;\n        for (var i = 0, len = this.children.length; i < len; i++) {\n          chunk = this.children[i];\n          if (chunk instanceof SourceNode) {\n            chunk.walk(aFn);\n          } else {\n            if (chunk !== '') {\n              aFn(chunk, {\n                source: this.source,\n                line: this.line,\n                column: this.column,\n                name: this.name\n              });\n            }\n          }\n        }\n      };\n      SourceNode.prototype.join = function SourceNode_join(aSep) {\n        var newChildren;\n        var i;\n        var len = this.children.length;\n        if (len > 0) {\n          newChildren = [];\n          for (i = 0; i < len - 1; i++) {\n            newChildren.push(this.children[i]);\n            newChildren.push(aSep);\n          }\n          newChildren.push(this.children[i]);\n          this.children = newChildren;\n        }\n        return this;\n      };\n      SourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {\n        var lastChild = this.children[this.children.length - 1];\n        if (lastChild instanceof SourceNode) {\n          lastChild.replaceRight(aPattern, aReplacement);\n        } else if (typeof lastChild === 'string') {\n          this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);\n        } else {\n          this.children.push(''.replace(aPattern, aReplacement));\n        }\n        return this;\n      };\n      SourceNode.prototype.setSourceContent = function SourceNode_setSourceContent(aSourceFile, aSourceContent) {\n        this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;\n      };\n      SourceNode.prototype.walkSourceContents = function SourceNode_walkSourceContents(aFn) {\n        for (var i = 0, len = this.children.length; i < len; i++) {\n          if (this.children[i] instanceof SourceNode) {\n            this.children[i].walkSourceContents(aFn);\n          }\n        }\n        var sources = Object.keys(this.sourceContents);\n        for (var i = 0, len = sources.length; i < len; i++) {\n          aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);\n        }\n      };\n      SourceNode.prototype.toString = function SourceNode_toString() {\n        var str = '';\n        this.walk(function (chunk) {\n          str += chunk;\n        });\n        return str;\n      };\n      SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {\n        var generated = {\n            code: '',\n            line: 1,\n            column: 0\n          };\n        var map = new SourceMapGenerator(aArgs);\n        var sourceMappingActive = false;\n        var lastOriginalSource = null;\n        var lastOriginalLine = null;\n        var lastOriginalColumn = null;\n        var lastOriginalName = null;\n        this.walk(function (chunk, original) {\n          generated.code += chunk;\n          if (original.source !== null && original.line !== null && original.column !== null) {\n            if (lastOriginalSource !== original.source || lastOriginalLine !== original.line || lastOriginalColumn !== original.column || lastOriginalName !== original.name) {\n              map.addMapping({\n                source: original.source,\n                original: {\n                  line: original.line,\n                  column: original.column\n                },\n                generated: {\n                  line: generated.line,\n                  column: generated.column\n                },\n                name: original.name\n              });\n            }\n            lastOriginalSource = original.source;\n            lastOriginalLine = original.line;\n            lastOriginalColumn = original.column;\n            lastOriginalName = original.name;\n            sourceMappingActive = true;\n          } else if (sourceMappingActive) {\n            map.addMapping({\n              generated: {\n                line: generated.line,\n                column: generated.column\n              }\n            });\n            lastOriginalSource = null;\n            sourceMappingActive = false;\n          }\n          chunk.match(REGEX_CHARACTER).forEach(function (ch, idx, array) {\n            if (REGEX_NEWLINE.test(ch)) {\n              generated.line++;\n              generated.column = 0;\n              if (idx + 1 === array.length) {\n                lastOriginalSource = null;\n                sourceMappingActive = false;\n              } else if (sourceMappingActive) {\n                map.addMapping({\n                  source: original.source,\n                  original: {\n                    line: original.line,\n                    column: original.column\n                  },\n                  generated: {\n                    line: generated.line,\n                    column: generated.column\n                  },\n                  name: original.name\n                });\n              }\n            } else {\n              generated.column += ch.length;\n            }\n          });\n        });\n        this.walkSourceContents(function (sourceFile, sourceContent) {\n          map.setSourceContent(sourceFile, sourceContent);\n        });\n        return {\n          code: generated.code,\n          map: map\n        };\n      };\n      exports.SourceNode = SourceNode;\n    });\n  });\n  require.define('/node_modules/source-map/lib/source-map/util.js', function (module, exports, __dirname, __filename) {\n    if (typeof define !== 'function') {\n      var define = require('/node_modules/source-map/node_modules/amdefine/amdefine.js', module)(module, require);\n    }\n    define(function (require, exports, module) {\n      function getArg(aArgs, aName, aDefaultValue) {\n        if (aName in aArgs) {\n          return aArgs[aName];\n        } else if (arguments.length === 3) {\n          return aDefaultValue;\n        } else {\n          throw new Error('\"' + aName + '\" is a required argument.');\n        }\n      }\n      exports.getArg = getArg;\n      var urlRegexp = /^(?:([\\w+\\-.]+):)?\\/\\/(?:(\\w+:\\w+)@)?([\\w.]*)(?::(\\d+))?(\\S*)$/;\n      var dataUrlRegexp = /^data:.+\\,.+$/;\n      function urlParse(aUrl) {\n        var match = aUrl.match(urlRegexp);\n        if (!match) {\n          return null;\n        }\n        return {\n          scheme: match[1],\n          auth: match[2],\n          host: match[3],\n          port: match[4],\n          path: match[5]\n        };\n      }\n      exports.urlParse = urlParse;\n      function urlGenerate(aParsedUrl) {\n        var url = '';\n        if (aParsedUrl.scheme) {\n          url += aParsedUrl.scheme + ':';\n        }\n        url += '//';\n        if (aParsedUrl.auth) {\n          url += aParsedUrl.auth + '@';\n        }\n        if (aParsedUrl.host) {\n          url += aParsedUrl.host;\n        }\n        if (aParsedUrl.port) {\n          url += ':' + aParsedUrl.port;\n        }\n        if (aParsedUrl.path) {\n          url += aParsedUrl.path;\n        }\n        return url;\n      }\n      exports.urlGenerate = urlGenerate;\n      function normalize(aPath) {\n        var path = aPath;\n        var url = urlParse(aPath);\n        if (url) {\n          if (!url.path) {\n            return aPath;\n          }\n          path = url.path;\n        }\n        var isAbsolute = path.charAt(0) === '/';\n        var parts = path.split(/\\/+/);\n        for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {\n          part = parts[i];\n          if (part === '.') {\n            parts.splice(i, 1);\n          } else if (part === '..') {\n            up++;\n          } else if (up > 0) {\n            if (part === '') {\n              parts.splice(i + 1, up);\n              up = 0;\n            } else {\n              parts.splice(i, 2);\n              up--;\n            }\n          }\n        }\n        path = parts.join('/');\n        if (path === '') {\n          path = isAbsolute ? '/' : '.';\n        }\n        if (url) {\n          url.path = path;\n          return urlGenerate(url);\n        }\n        return path;\n      }\n      exports.normalize = normalize;\n      function join(aRoot, aPath) {\n        if (aRoot === '') {\n          aRoot = '.';\n        }\n        if (aPath === '') {\n          aPath = '.';\n        }\n        var aPathUrl = urlParse(aPath);\n        var aRootUrl = urlParse(aRoot);\n        if (aRootUrl) {\n          aRoot = aRootUrl.path || '/';\n        }\n        if (aPathUrl && !aPathUrl.scheme) {\n          if (aRootUrl) {\n            aPathUrl.scheme = aRootUrl.scheme;\n          }\n          return urlGenerate(aPathUrl);\n        }\n        if (aPathUrl || aPath.match(dataUrlRegexp)) {\n          return aPath;\n        }\n        if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {\n          aRootUrl.host = aPath;\n          return urlGenerate(aRootUrl);\n        }\n        var joined = aPath.charAt(0) === '/' ? aPath : normalize(aRoot.replace(/\\/+$/, '') + '/' + aPath);\n        if (aRootUrl) {\n          aRootUrl.path = joined;\n          return urlGenerate(aRootUrl);\n        }\n        return joined;\n      }\n      exports.join = join;\n      function relative(aRoot, aPath) {\n        if (aRoot === '') {\n          aRoot = '.';\n        }\n        aRoot = aRoot.replace(/\\/$/, '');\n        var url = urlParse(aRoot);\n        if (aPath.charAt(0) == '/' && url && url.path == '/') {\n          return aPath.slice(1);\n        }\n        return aPath.indexOf(aRoot + '/') === 0 ? aPath.substr(aRoot.length + 1) : aPath;\n      }\n      exports.relative = relative;\n      function toSetString(aStr) {\n        return '$' + aStr;\n      }\n      exports.toSetString = toSetString;\n      function fromSetString(aStr) {\n        return aStr.substr(1);\n      }\n      exports.fromSetString = fromSetString;\n      function strcmp(aStr1, aStr2) {\n        var s1 = aStr1 || '';\n        var s2 = aStr2 || '';\n        return (s1 > s2) - (s1 < s2);\n      }\n      function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {\n        var cmp;\n        cmp = strcmp(mappingA.source, mappingB.source);\n        if (cmp) {\n          return cmp;\n        }\n        cmp = mappingA.originalLine - mappingB.originalLine;\n        if (cmp) {\n          return cmp;\n        }\n        cmp = mappingA.originalColumn - mappingB.originalColumn;\n        if (cmp || onlyCompareOriginal) {\n          return cmp;\n        }\n        cmp = strcmp(mappingA.name, mappingB.name);\n        if (cmp) {\n          return cmp;\n        }\n        cmp = mappingA.generatedLine - mappingB.generatedLine;\n        if (cmp) {\n          return cmp;\n        }\n        return mappingA.generatedColumn - mappingB.generatedColumn;\n      }\n      ;\n      exports.compareByOriginalPositions = compareByOriginalPositions;\n      function compareByGeneratedPositions(mappingA, mappingB, onlyCompareGenerated) {\n        var cmp;\n        cmp = mappingA.generatedLine - mappingB.generatedLine;\n        if (cmp) {\n          return cmp;\n        }\n        cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n        if (cmp || onlyCompareGenerated) {\n          return cmp;\n        }\n        cmp = strcmp(mappingA.source, mappingB.source);\n        if (cmp) {\n          return cmp;\n        }\n        cmp = mappingA.originalLine - mappingB.originalLine;\n        if (cmp) {\n          return cmp;\n        }\n        cmp = mappingA.originalColumn - mappingB.originalColumn;\n        if (cmp) {\n          return cmp;\n        }\n        return strcmp(mappingA.name, mappingB.name);\n      }\n      ;\n      exports.compareByGeneratedPositions = compareByGeneratedPositions;\n    });\n  });\n  require.define('/node_modules/source-map/node_modules/amdefine/amdefine.js', function (module, exports, __dirname, __filename) {\n    'use strict';\n    function amdefine(module, requireFn) {\n      'use strict';\n      var defineCache = {}, loaderCache = {}, alreadyCalled = false, path = require('path', module), makeRequire, stringRequire;\n      function trimDots(ary) {\n        var i, part;\n        for (i = 0; ary[i]; i += 1) {\n          part = ary[i];\n          if (part === '.') {\n            ary.splice(i, 1);\n            i -= 1;\n          } else if (part === '..') {\n            if (i === 1 && (ary[2] === '..' || ary[0] === '..')) {\n              break;\n            } else if (i > 0) {\n              ary.splice(i - 1, 2);\n              i -= 2;\n            }\n          }\n        }\n      }\n      function normalize(name, baseName) {\n        var baseParts;\n        if (name && name.charAt(0) === '.') {\n          if (baseName) {\n            baseParts = baseName.split('/');\n            baseParts = baseParts.slice(0, baseParts.length - 1);\n            baseParts = baseParts.concat(name.split('/'));\n            trimDots(baseParts);\n            name = baseParts.join('/');\n          }\n        }\n        return name;\n      }\n      function makeNormalize(relName) {\n        return function (name) {\n          return normalize(name, relName);\n        };\n      }\n      function makeLoad(id) {\n        function load(value) {\n          loaderCache[id] = value;\n        }\n        load.fromText = function (id, text) {\n          throw new Error('amdefine does not implement load.fromText');\n        };\n        return load;\n      }\n      makeRequire = function (systemRequire, exports, module, relId) {\n        function amdRequire(deps, callback) {\n          if (typeof deps === 'string') {\n            return stringRequire(systemRequire, exports, module, deps, relId);\n          } else {\n            deps = deps.map(function (depName) {\n              return stringRequire(systemRequire, exports, module, depName, relId);\n            });\n            process.nextTick(function () {\n              callback.apply(null, deps);\n            });\n          }\n        }\n        amdRequire.toUrl = function (filePath) {\n          if (filePath.indexOf('.') === 0) {\n            return normalize(filePath, path.dirname(module.filename));\n          } else {\n            return filePath;\n          }\n        };\n        return amdRequire;\n      };\n      requireFn = requireFn || function req() {\n        return module.require.apply(module, arguments);\n      };\n      function runFactory(id, deps, factory) {\n        var r, e, m, result;\n        if (id) {\n          e = loaderCache[id] = {};\n          m = {\n            id: id,\n            uri: __filename,\n            exports: e\n          };\n          r = makeRequire(requireFn, e, m, id);\n        } else {\n          if (alreadyCalled) {\n            throw new Error('amdefine with no module ID cannot be called more than once per file.');\n          }\n          alreadyCalled = true;\n          e = module.exports;\n          m = module;\n          r = makeRequire(requireFn, e, m, module.id);\n        }\n        if (deps) {\n          deps = deps.map(function (depName) {\n            return r(depName);\n          });\n        }\n        if (typeof factory === 'function') {\n          result = factory.apply(m.exports, deps);\n        } else {\n          result = factory;\n        }\n        if (result !== undefined) {\n          m.exports = result;\n          if (id) {\n            loaderCache[id] = m.exports;\n          }\n        }\n      }\n      stringRequire = function (systemRequire, exports, module, id, relId) {\n        var index = id.indexOf('!'), originalId = id, prefix, plugin;\n        if (index === -1) {\n          id = normalize(id, relId);\n          if (id === 'require') {\n            return makeRequire(systemRequire, exports, module, relId);\n          } else if (id === 'exports') {\n            return exports;\n          } else if (id === 'module') {\n            return module;\n          } else if (loaderCache.hasOwnProperty(id)) {\n            return loaderCache[id];\n          } else if (defineCache[id]) {\n            runFactory.apply(null, defineCache[id]);\n            return loaderCache[id];\n          } else {\n            if (systemRequire) {\n              return systemRequire(originalId);\n            } else {\n              throw new Error('No module with ID: ' + id);\n            }\n          }\n        } else {\n          prefix = id.substring(0, index);\n          id = id.substring(index + 1, id.length);\n          plugin = stringRequire(systemRequire, exports, module, prefix, relId);\n          if (plugin.normalize) {\n            id = plugin.normalize(id, makeNormalize(relId));\n          } else {\n            id = normalize(id, relId);\n          }\n          if (loaderCache[id]) {\n            return loaderCache[id];\n          } else {\n            plugin.load(id, makeRequire(systemRequire, exports, module, relId), makeLoad(id), {});\n            return loaderCache[id];\n          }\n        }\n      };\n      function define(id, deps, factory) {\n        if (Array.isArray(id)) {\n          factory = deps;\n          deps = id;\n          id = undefined;\n        } else if (typeof id !== 'string') {\n          factory = id;\n          id = deps = undefined;\n        }\n        if (deps && !Array.isArray(deps)) {\n          factory = deps;\n          deps = undefined;\n        }\n        if (!deps) {\n          deps = [\n            'require',\n            'exports',\n            'module'\n          ];\n        }\n        if (id) {\n          defineCache[id] = [\n            id,\n            deps,\n            factory\n          ];\n        } else {\n          runFactory(id, deps, factory);\n        }\n      }\n      define.require = function (id) {\n        if (loaderCache[id]) {\n          return loaderCache[id];\n        }\n        if (defineCache[id]) {\n          runFactory.apply(null, defineCache[id]);\n          return loaderCache[id];\n        }\n      };\n      define.amd = {};\n      return define;\n    }\n    module.exports = amdefine;\n  });\n  require.define('/node_modules/source-map/lib/source-map/source-map-generator.js', function (module, exports, __dirname, __filename) {\n    if (typeof define !== 'function') {\n      var define = require('/node_modules/source-map/node_modules/amdefine/amdefine.js', module)(module, require);\n    }\n    define(function (require, exports, module) {\n      var base64VLQ = require('/node_modules/source-map/lib/source-map/base64-vlq.js', module);\n      var util = require('/node_modules/source-map/lib/source-map/util.js', module);\n      var ArraySet = require('/node_modules/source-map/lib/source-map/array-set.js', module).ArraySet;\n      function SourceMapGenerator(aArgs) {\n        if (!aArgs) {\n          aArgs = {};\n        }\n        this._file = util.getArg(aArgs, 'file', null);\n        this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);\n        this._sources = new ArraySet;\n        this._names = new ArraySet;\n        this._mappings = [];\n        this._sourcesContents = null;\n      }\n      SourceMapGenerator.prototype._version = 3;\n      SourceMapGenerator.fromSourceMap = function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {\n        var sourceRoot = aSourceMapConsumer.sourceRoot;\n        var generator = new SourceMapGenerator({\n            file: aSourceMapConsumer.file,\n            sourceRoot: sourceRoot\n          });\n        aSourceMapConsumer.eachMapping(function (mapping) {\n          var newMapping = {\n              generated: {\n                line: mapping.generatedLine,\n                column: mapping.generatedColumn\n              }\n            };\n          if (mapping.source != null) {\n            newMapping.source = mapping.source;\n            if (sourceRoot != null) {\n              newMapping.source = util.relative(sourceRoot, newMapping.source);\n            }\n            newMapping.original = {\n              line: mapping.originalLine,\n              column: mapping.originalColumn\n            };\n            if (mapping.name != null) {\n              newMapping.name = mapping.name;\n            }\n          }\n          generator.addMapping(newMapping);\n        });\n        aSourceMapConsumer.sources.forEach(function (sourceFile) {\n          var content = aSourceMapConsumer.sourceContentFor(sourceFile);\n          if (content != null) {\n            generator.setSourceContent(sourceFile, content);\n          }\n        });\n        return generator;\n      };\n      SourceMapGenerator.prototype.addMapping = function SourceMapGenerator_addMapping(aArgs) {\n        var generated = util.getArg(aArgs, 'generated');\n        var original = util.getArg(aArgs, 'original', null);\n        var source = util.getArg(aArgs, 'source', null);\n        var name = util.getArg(aArgs, 'name', null);\n        this._validateMapping(generated, original, source, name);\n        if (source != null && !this._sources.has(source)) {\n          this._sources.add(source);\n        }\n        if (name != null && !this._names.has(name)) {\n          this._names.add(name);\n        }\n        this._mappings.push({\n          generatedLine: generated.line,\n          generatedColumn: generated.column,\n          originalLine: original != null && original.line,\n          originalColumn: original != null && original.column,\n          source: source,\n          name: name\n        });\n      };\n      SourceMapGenerator.prototype.setSourceContent = function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {\n        var source = aSourceFile;\n        if (this._sourceRoot != null) {\n          source = util.relative(this._sourceRoot, source);\n        }\n        if (aSourceContent != null) {\n          if (!this._sourcesContents) {\n            this._sourcesContents = {};\n          }\n          this._sourcesContents[util.toSetString(source)] = aSourceContent;\n        } else if (this._sourcesContents) {\n          delete this._sourcesContents[util.toSetString(source)];\n          if (Object.keys(this._sourcesContents).length === 0) {\n            this._sourcesContents = null;\n          }\n        }\n      };\n      SourceMapGenerator.prototype.applySourceMap = function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {\n        var sourceFile = aSourceFile;\n        if (aSourceFile == null) {\n          if (aSourceMapConsumer.file == null) {\n            throw new Error('SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' + 'or the source map\\'s \"file\" property. Both were omitted.');\n          }\n          sourceFile = aSourceMapConsumer.file;\n        }\n        var sourceRoot = this._sourceRoot;\n        if (sourceRoot != null) {\n          sourceFile = util.relative(sourceRoot, sourceFile);\n        }\n        var newSources = new ArraySet;\n        var newNames = new ArraySet;\n        this._mappings.forEach(function (mapping) {\n          if (mapping.source === sourceFile && mapping.originalLine != null) {\n            var original = aSourceMapConsumer.originalPositionFor({\n                line: mapping.originalLine,\n                column: mapping.originalColumn\n              });\n            if (original.source != null) {\n              mapping.source = original.source;\n              if (aSourceMapPath != null) {\n                mapping.source = util.join(aSourceMapPath, mapping.source);\n              }\n              if (sourceRoot != null) {\n                mapping.source = util.relative(sourceRoot, mapping.source);\n              }\n              mapping.originalLine = original.line;\n              mapping.originalColumn = original.column;\n              if (original.name != null) {\n                mapping.name = original.name;\n              }\n            }\n          }\n          var source = mapping.source;\n          if (source != null && !newSources.has(source)) {\n            newSources.add(source);\n          }\n          var name = mapping.name;\n          if (name != null && !newNames.has(name)) {\n            newNames.add(name);\n          }\n        }, this);\n        this._sources = newSources;\n        this._names = newNames;\n        aSourceMapConsumer.sources.forEach(function (sourceFile) {\n          var content = aSourceMapConsumer.sourceContentFor(sourceFile);\n          if (content != null) {\n            if (aSourceMapPath != null) {\n              sourceFile = util.join(aSourceMapPath, sourceFile);\n            }\n            if (sourceRoot != null) {\n              sourceFile = util.relative(sourceRoot, sourceFile);\n            }\n            this.setSourceContent(sourceFile, content);\n          }\n        }, this);\n      };\n      SourceMapGenerator.prototype._validateMapping = function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource, aName) {\n        if (aGenerated && 'line' in aGenerated && 'column' in aGenerated && aGenerated.line > 0 && aGenerated.column >= 0 && !aOriginal && !aSource && !aName) {\n          return;\n        } else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated && aOriginal && 'line' in aOriginal && 'column' in aOriginal && aGenerated.line > 0 && aGenerated.column >= 0 && aOriginal.line > 0 && aOriginal.column >= 0 && aSource) {\n          return;\n        } else {\n          throw new Error('Invalid mapping: ' + JSON.stringify({\n            generated: aGenerated,\n            source: aSource,\n            original: aOriginal,\n            name: aName\n          }));\n        }\n      };\n      SourceMapGenerator.prototype._serializeMappings = function SourceMapGenerator_serializeMappings() {\n        var previousGeneratedColumn = 0;\n        var previousGeneratedLine = 1;\n        var previousOriginalColumn = 0;\n        var previousOriginalLine = 0;\n        var previousName = 0;\n        var previousSource = 0;\n        var result = '';\n        var mapping;\n        this._mappings.sort(util.compareByGeneratedPositions);\n        for (var i = 0, len = this._mappings.length; i < len; i++) {\n          mapping = this._mappings[i];\n          if (mapping.generatedLine !== previousGeneratedLine) {\n            previousGeneratedColumn = 0;\n            while (mapping.generatedLine !== previousGeneratedLine) {\n              result += ';';\n              previousGeneratedLine++;\n            }\n          } else {\n            if (i > 0) {\n              if (!util.compareByGeneratedPositions(mapping, this._mappings[i - 1])) {\n                continue;\n              }\n              result += ',';\n            }\n          }\n          result += base64VLQ.encode(mapping.generatedColumn - previousGeneratedColumn);\n          previousGeneratedColumn = mapping.generatedColumn;\n          if (mapping.source != null) {\n            result += base64VLQ.encode(this._sources.indexOf(mapping.source) - previousSource);\n            previousSource = this._sources.indexOf(mapping.source);\n            result += base64VLQ.encode(mapping.originalLine - 1 - previousOriginalLine);\n            previousOriginalLine = mapping.originalLine - 1;\n            result += base64VLQ.encode(mapping.originalColumn - previousOriginalColumn);\n            previousOriginalColumn = mapping.originalColumn;\n            if (mapping.name != null) {\n              result += base64VLQ.encode(this._names.indexOf(mapping.name) - previousName);\n              previousName = this._names.indexOf(mapping.name);\n            }\n          }\n        }\n        return result;\n      };\n      SourceMapGenerator.prototype._generateSourcesContent = function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {\n        return aSources.map(function (source) {\n          if (!this._sourcesContents) {\n            return null;\n          }\n          if (aSourceRoot != null) {\n            source = util.relative(aSourceRoot, source);\n          }\n          var key = util.toSetString(source);\n          return Object.prototype.hasOwnProperty.call(this._sourcesContents, key) ? this._sourcesContents[key] : null;\n        }, this);\n      };\n      SourceMapGenerator.prototype.toJSON = function SourceMapGenerator_toJSON() {\n        var map = {\n            version: this._version,\n            sources: this._sources.toArray(),\n            names: this._names.toArray(),\n            mappings: this._serializeMappings()\n          };\n        if (this._file != null) {\n          map.file = this._file;\n        }\n        if (this._sourceRoot != null) {\n          map.sourceRoot = this._sourceRoot;\n        }\n        if (this._sourcesContents) {\n          map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);\n        }\n        return map;\n      };\n      SourceMapGenerator.prototype.toString = function SourceMapGenerator_toString() {\n        return JSON.stringify(this);\n      };\n      exports.SourceMapGenerator = SourceMapGenerator;\n    });\n  });\n  require.define('/node_modules/source-map/lib/source-map/array-set.js', function (module, exports, __dirname, __filename) {\n    if (typeof define !== 'function') {\n      var define = require('/node_modules/source-map/node_modules/amdefine/amdefine.js', module)(module, require);\n    }\n    define(function (require, exports, module) {\n      var util = require('/node_modules/source-map/lib/source-map/util.js', module);\n      function ArraySet() {\n        this._array = [];\n        this._set = {};\n      }\n      ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {\n        var set = new ArraySet;\n        for (var i = 0, len = aArray.length; i < len; i++) {\n          set.add(aArray[i], aAllowDuplicates);\n        }\n        return set;\n      };\n      ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {\n        var isDuplicate = this.has(aStr);\n        var idx = this._array.length;\n        if (!isDuplicate || aAllowDuplicates) {\n          this._array.push(aStr);\n        }\n        if (!isDuplicate) {\n          this._set[util.toSetString(aStr)] = idx;\n        }\n      };\n      ArraySet.prototype.has = function ArraySet_has(aStr) {\n        return Object.prototype.hasOwnProperty.call(this._set, util.toSetString(aStr));\n      };\n      ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {\n        if (this.has(aStr)) {\n          return this._set[util.toSetString(aStr)];\n        }\n        throw new Error('\"' + aStr + '\" is not in the set.');\n      };\n      ArraySet.prototype.at = function ArraySet_at(aIdx) {\n        if (aIdx >= 0 && aIdx < this._array.length) {\n          return this._array[aIdx];\n        }\n        throw new Error('No element indexed by ' + aIdx);\n      };\n      ArraySet.prototype.toArray = function ArraySet_toArray() {\n        return this._array.slice();\n      };\n      exports.ArraySet = ArraySet;\n    });\n  });\n  require.define('/node_modules/source-map/lib/source-map/base64-vlq.js', function (module, exports, __dirname, __filename) {\n    if (typeof define !== 'function') {\n      var define = require('/node_modules/source-map/node_modules/amdefine/amdefine.js', module)(module, require);\n    }\n    define(function (require, exports, module) {\n      var base64 = require('/node_modules/source-map/lib/source-map/base64.js', module);\n      var VLQ_BASE_SHIFT = 5;\n      var VLQ_BASE = 1 << VLQ_BASE_SHIFT;\n      var VLQ_BASE_MASK = VLQ_BASE - 1;\n      var VLQ_CONTINUATION_BIT = VLQ_BASE;\n      function toVLQSigned(aValue) {\n        return aValue < 0 ? (-aValue << 1) + 1 : (aValue << 1) + 0;\n      }\n      function fromVLQSigned(aValue) {\n        var isNegative = (aValue & 1) === 1;\n        var shifted = aValue >> 1;\n        return isNegative ? -shifted : shifted;\n      }\n      exports.encode = function base64VLQ_encode(aValue) {\n        var encoded = '';\n        var digit;\n        var vlq = toVLQSigned(aValue);\n        do {\n          digit = vlq & VLQ_BASE_MASK;\n          vlq >>>= VLQ_BASE_SHIFT;\n          if (vlq > 0) {\n            digit |= VLQ_CONTINUATION_BIT;\n          }\n          encoded += base64.encode(digit);\n        } while (vlq > 0);\n        return encoded;\n      };\n      exports.decode = function base64VLQ_decode(aStr, aOutParam) {\n        var i = 0;\n        var strLen = aStr.length;\n        var result = 0;\n        var shift = 0;\n        var continuation, digit;\n        do {\n          if (i >= strLen) {\n            throw new Error('Expected more digits in base 64 VLQ value.');\n          }\n          digit = base64.decode(aStr.charAt(i++));\n          continuation = !!(digit & VLQ_CONTINUATION_BIT);\n          digit &= VLQ_BASE_MASK;\n          result = result + (digit << shift);\n          shift += VLQ_BASE_SHIFT;\n        } while (continuation);\n        aOutParam.value = fromVLQSigned(result);\n        aOutParam.rest = aStr.slice(i);\n      };\n    });\n  });\n  require.define('/node_modules/source-map/lib/source-map/base64.js', function (module, exports, __dirname, __filename) {\n    if (typeof define !== 'function') {\n      var define = require('/node_modules/source-map/node_modules/amdefine/amdefine.js', module)(module, require);\n    }\n    define(function (require, exports, module) {\n      var charToIntMap = {};\n      var intToCharMap = {};\n      'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('').forEach(function (ch, index) {\n        charToIntMap[ch] = index;\n        intToCharMap[index] = ch;\n      });\n      exports.encode = function base64_encode(aNumber) {\n        if (aNumber in intToCharMap) {\n          return intToCharMap[aNumber];\n        }\n        throw new TypeError('Must be between 0 and 63: ' + aNumber);\n      };\n      exports.decode = function base64_decode(aChar) {\n        if (aChar in charToIntMap) {\n          return charToIntMap[aChar];\n        }\n        throw new TypeError('Not a valid base 64 digit: ' + aChar);\n      };\n    });\n  });\n  require.define('/node_modules/source-map/lib/source-map/source-map-consumer.js', function (module, exports, __dirname, __filename) {\n    if (typeof define !== 'function') {\n      var define = require('/node_modules/source-map/node_modules/amdefine/amdefine.js', module)(module, require);\n    }\n    define(function (require, exports, module) {\n      var util = require('/node_modules/source-map/lib/source-map/util.js', module);\n      var binarySearch = require('/node_modules/source-map/lib/source-map/binary-search.js', module);\n      var ArraySet = require('/node_modules/source-map/lib/source-map/array-set.js', module).ArraySet;\n      var base64VLQ = require('/node_modules/source-map/lib/source-map/base64-vlq.js', module);\n      function SourceMapConsumer(aSourceMap) {\n        var sourceMap = aSourceMap;\n        if (typeof aSourceMap === 'string') {\n          sourceMap = JSON.parse(aSourceMap.replace(/^\\)\\]\\}'/, ''));\n        }\n        var version = util.getArg(sourceMap, 'version');\n        var sources = util.getArg(sourceMap, 'sources');\n        var names = util.getArg(sourceMap, 'names', []);\n        var sourceRoot = util.getArg(sourceMap, 'sourceRoot', null);\n        var sourcesContent = util.getArg(sourceMap, 'sourcesContent', null);\n        var mappings = util.getArg(sourceMap, 'mappings');\n        var file = util.getArg(sourceMap, 'file', null);\n        if (version != this._version) {\n          throw new Error('Unsupported version: ' + version);\n        }\n        this._names = ArraySet.fromArray(names, true);\n        this._sources = ArraySet.fromArray(sources, true);\n        this.sourceRoot = sourceRoot;\n        this.sourcesContent = sourcesContent;\n        this._mappings = mappings;\n        this.file = file;\n      }\n      SourceMapConsumer.fromSourceMap = function SourceMapConsumer_fromSourceMap(aSourceMap) {\n        var smc = Object.create(SourceMapConsumer.prototype);\n        smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);\n        smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);\n        smc.sourceRoot = aSourceMap._sourceRoot;\n        smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(), smc.sourceRoot);\n        smc.file = aSourceMap._file;\n        smc.__generatedMappings = aSourceMap._mappings.slice().sort(util.compareByGeneratedPositions);\n        smc.__originalMappings = aSourceMap._mappings.slice().sort(util.compareByOriginalPositions);\n        return smc;\n      };\n      SourceMapConsumer.prototype._version = 3;\n      Object.defineProperty(SourceMapConsumer.prototype, 'sources', {\n        get: function () {\n          return this._sources.toArray().map(function (s) {\n            return this.sourceRoot != null ? util.join(this.sourceRoot, s) : s;\n          }, this);\n        }\n      });\n      SourceMapConsumer.prototype.__generatedMappings = null;\n      Object.defineProperty(SourceMapConsumer.prototype, '_generatedMappings', {\n        get: function () {\n          if (!this.__generatedMappings) {\n            this.__generatedMappings = [];\n            this.__originalMappings = [];\n            this._parseMappings(this._mappings, this.sourceRoot);\n          }\n          return this.__generatedMappings;\n        }\n      });\n      SourceMapConsumer.prototype.__originalMappings = null;\n      Object.defineProperty(SourceMapConsumer.prototype, '_originalMappings', {\n        get: function () {\n          if (!this.__originalMappings) {\n            this.__generatedMappings = [];\n            this.__originalMappings = [];\n            this._parseMappings(this._mappings, this.sourceRoot);\n          }\n          return this.__originalMappings;\n        }\n      });\n      SourceMapConsumer.prototype._nextCharIsMappingSeparator = function SourceMapConsumer_nextCharIsMappingSeparator(aStr) {\n        var c = aStr.charAt(0);\n        return c === ';' || c === ',';\n      };\n      SourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {\n        var generatedLine = 1;\n        var previousGeneratedColumn = 0;\n        var previousOriginalLine = 0;\n        var previousOriginalColumn = 0;\n        var previousSource = 0;\n        var previousName = 0;\n        var str = aStr;\n        var temp = {};\n        var mapping;\n        while (str.length > 0) {\n          if (str.charAt(0) === ';') {\n            generatedLine++;\n            str = str.slice(1);\n            previousGeneratedColumn = 0;\n          } else if (str.charAt(0) === ',') {\n            str = str.slice(1);\n          } else {\n            mapping = {};\n            mapping.generatedLine = generatedLine;\n            base64VLQ.decode(str, temp);\n            mapping.generatedColumn = previousGeneratedColumn + temp.value;\n            previousGeneratedColumn = mapping.generatedColumn;\n            str = temp.rest;\n            if (str.length > 0 && !this._nextCharIsMappingSeparator(str)) {\n              base64VLQ.decode(str, temp);\n              mapping.source = this._sources.at(previousSource + temp.value);\n              previousSource += temp.value;\n              str = temp.rest;\n              if (str.length === 0 || this._nextCharIsMappingSeparator(str)) {\n                throw new Error('Found a source, but no line and column');\n              }\n              base64VLQ.decode(str, temp);\n              mapping.originalLine = previousOriginalLine + temp.value;\n              previousOriginalLine = mapping.originalLine;\n              mapping.originalLine += 1;\n              str = temp.rest;\n              if (str.length === 0 || this._nextCharIsMappingSeparator(str)) {\n                throw new Error('Found a source and line, but no column');\n              }\n              base64VLQ.decode(str, temp);\n              mapping.originalColumn = previousOriginalColumn + temp.value;\n              previousOriginalColumn = mapping.originalColumn;\n              str = temp.rest;\n              if (str.length > 0 && !this._nextCharIsMappingSeparator(str)) {\n                base64VLQ.decode(str, temp);\n                mapping.name = this._names.at(previousName + temp.value);\n                previousName += temp.value;\n                str = temp.rest;\n              }\n            }\n            this.__generatedMappings.push(mapping);\n            if (typeof mapping.originalLine === 'number') {\n              this.__originalMappings.push(mapping);\n            }\n          }\n        }\n        this.__generatedMappings.sort(util.compareByGeneratedPositions);\n        this.__originalMappings.sort(util.compareByOriginalPositions);\n      };\n      SourceMapConsumer.prototype._findMapping = function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName, aColumnName, aComparator) {\n        if (aNeedle[aLineName] <= 0) {\n          throw new TypeError('Line must be greater than or equal to 1, got ' + aNeedle[aLineName]);\n        }\n        if (aNeedle[aColumnName] < 0) {\n          throw new TypeError('Column must be greater than or equal to 0, got ' + aNeedle[aColumnName]);\n        }\n        return binarySearch.search(aNeedle, aMappings, aComparator);\n      };\n      SourceMapConsumer.prototype.originalPositionFor = function SourceMapConsumer_originalPositionFor(aArgs) {\n        var needle = {\n            generatedLine: util.getArg(aArgs, 'line'),\n            generatedColumn: util.getArg(aArgs, 'column')\n          };\n        var mapping = this._findMapping(needle, this._generatedMappings, 'generatedLine', 'generatedColumn', util.compareByGeneratedPositions);\n        if (mapping && mapping.generatedLine === needle.generatedLine) {\n          var source = util.getArg(mapping, 'source', null);\n          if (source != null && this.sourceRoot != null) {\n            source = util.join(this.sourceRoot, source);\n          }\n          return {\n            source: source,\n            line: util.getArg(mapping, 'originalLine', null),\n            column: util.getArg(mapping, 'originalColumn', null),\n            name: util.getArg(mapping, 'name', null)\n          };\n        }\n        return {\n          source: null,\n          line: null,\n          column: null,\n          name: null\n        };\n      };\n      SourceMapConsumer.prototype.sourceContentFor = function SourceMapConsumer_sourceContentFor(aSource) {\n        if (!this.sourcesContent) {\n          return null;\n        }\n        if (this.sourceRoot != null) {\n          aSource = util.relative(this.sourceRoot, aSource);\n        }\n        if (this._sources.has(aSource)) {\n          return this.sourcesContent[this._sources.indexOf(aSource)];\n        }\n        var url;\n        if (this.sourceRoot != null && (url = util.urlParse(this.sourceRoot))) {\n          var fileUriAbsPath = aSource.replace(/^file:\\/\\//, '');\n          if (url.scheme == 'file' && this._sources.has(fileUriAbsPath)) {\n            return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)];\n          }\n          if ((!url.path || url.path == '/') && this._sources.has('/' + aSource)) {\n            return this.sourcesContent[this._sources.indexOf('/' + aSource)];\n          }\n        }\n        throw new Error('\"' + aSource + '\" is not in the SourceMap.');\n      };\n      SourceMapConsumer.prototype.generatedPositionFor = function SourceMapConsumer_generatedPositionFor(aArgs) {\n        var needle = {\n            source: util.getArg(aArgs, 'source'),\n            originalLine: util.getArg(aArgs, 'line'),\n            originalColumn: util.getArg(aArgs, 'column')\n          };\n        if (this.sourceRoot != null) {\n          needle.source = util.relative(this.sourceRoot, needle.source);\n        }\n        var mapping = this._findMapping(needle, this._originalMappings, 'originalLine', 'originalColumn', util.compareByOriginalPositions);\n        if (mapping) {\n          return {\n            line: util.getArg(mapping, 'generatedLine', null),\n            column: util.getArg(mapping, 'generatedColumn', null)\n          };\n        }\n        return {\n          line: null,\n          column: null\n        };\n      };\n      SourceMapConsumer.GENERATED_ORDER = 1;\n      SourceMapConsumer.ORIGINAL_ORDER = 2;\n      SourceMapConsumer.prototype.eachMapping = function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {\n        var context = aContext || null;\n        var order = aOrder || SourceMapConsumer.GENERATED_ORDER;\n        var mappings;\n        switch (order) {\n        case SourceMapConsumer.GENERATED_ORDER:\n          mappings = this._generatedMappings;\n          break;\n        case SourceMapConsumer.ORIGINAL_ORDER:\n          mappings = this._originalMappings;\n          break;\n        default:\n          throw new Error('Unknown order of iteration.');\n        }\n        var sourceRoot = this.sourceRoot;\n        mappings.map(function (mapping) {\n          var source = mapping.source;\n          if (source != null && sourceRoot != null) {\n            source = util.join(sourceRoot, source);\n          }\n          return {\n            source: source,\n            generatedLine: mapping.generatedLine,\n            generatedColumn: mapping.generatedColumn,\n            originalLine: mapping.originalLine,\n            originalColumn: mapping.originalColumn,\n            name: mapping.name\n          };\n        }).forEach(aCallback, context);\n      };\n      exports.SourceMapConsumer = SourceMapConsumer;\n    });\n  });\n  require.define('/node_modules/source-map/lib/source-map/binary-search.js', function (module, exports, __dirname, __filename) {\n    if (typeof define !== 'function') {\n      var define = require('/node_modules/source-map/node_modules/amdefine/amdefine.js', module)(module, require);\n    }\n    define(function (require, exports, module) {\n      function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare) {\n        var mid = Math.floor((aHigh - aLow) / 2) + aLow;\n        var cmp = aCompare(aNeedle, aHaystack[mid], true);\n        if (cmp === 0) {\n          return aHaystack[mid];\n        } else if (cmp > 0) {\n          if (aHigh - mid > 1) {\n            return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare);\n          }\n          return aHaystack[mid];\n        } else {\n          if (mid - aLow > 1) {\n            return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare);\n          }\n          return aLow < 0 ? null : aHaystack[aLow];\n        }\n      }\n      exports.search = function search(aNeedle, aHaystack, aCompare) {\n        return aHaystack.length > 0 ? recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack, aCompare) : null;\n      };\n    });\n  });\n  require.define('/node_modules/esutils/lib/utils.js', function (module, exports, __dirname, __filename) {\n    (function () {\n      'use strict';\n      exports.ast = require('/node_modules/esutils/lib/ast.js', module);\n      exports.code = require('/node_modules/esutils/lib/code.js', module);\n      exports.keyword = require('/node_modules/esutils/lib/keyword.js', module);\n    }());\n  });\n  require.define('/node_modules/esutils/lib/keyword.js', function (module, exports, __dirname, __filename) {\n    (function () {\n      'use strict';\n      var code = require('/node_modules/esutils/lib/code.js', module);\n      function isStrictModeReservedWordES6(id) {\n        switch (id) {\n        case 'implements':\n        case 'interface':\n        case 'package':\n        case 'private':\n        case 'protected':\n        case 'public':\n        case 'static':\n        case 'let':\n          return true;\n        default:\n          return false;\n        }\n      }\n      function isKeywordES5(id, strict) {\n        if (!strict && id === 'yield') {\n          return false;\n        }\n        return isKeywordES6(id, strict);\n      }\n      function isKeywordES6(id, strict) {\n        if (strict && isStrictModeReservedWordES6(id)) {\n          return true;\n        }\n        switch (id.length) {\n        case 2:\n          return id === 'if' || id === 'in' || id === 'do';\n        case 3:\n          return id === 'var' || id === 'for' || id === 'new' || id === 'try';\n        case 4:\n          return id === 'this' || id === 'else' || id === 'case' || id === 'void' || id === 'with' || id === 'enum';\n        case 5:\n          return id === 'while' || id === 'break' || id === 'catch' || id === 'throw' || id === 'const' || id === 'yield' || id === 'class' || id === 'super';\n        case 6:\n          return id === 'return' || id === 'typeof' || id === 'delete' || id === 'switch' || id === 'export' || id === 'import';\n        case 7:\n          return id === 'default' || id === 'finally' || id === 'extends';\n        case 8:\n          return id === 'function' || id === 'continue' || id === 'debugger';\n        case 10:\n          return id === 'instanceof';\n        default:\n          return false;\n        }\n      }\n      function isReservedWordES5(id, strict) {\n        return id === 'null' || id === 'true' || id === 'false' || isKeywordES5(id, strict);\n      }\n      function isReservedWordES6(id, strict) {\n        return id === 'null' || id === 'true' || id === 'false' || isKeywordES6(id, strict);\n      }\n      function isRestrictedWord(id) {\n        return id === 'eval' || id === 'arguments';\n      }\n      function isIdentifierName(id) {\n        var i, iz, ch;\n        if (id.length === 0) {\n          return false;\n        }\n        ch = id.charCodeAt(0);\n        if (!code.isIdentifierStart(ch) || ch === 92) {\n          return false;\n        }\n        for (i = 1, iz = id.length; i < iz; ++i) {\n          ch = id.charCodeAt(i);\n          if (!code.isIdentifierPart(ch) || ch === 92) {\n            return false;\n          }\n        }\n        return true;\n      }\n      function isIdentifierES5(id, strict) {\n        return isIdentifierName(id) && !isReservedWordES5(id, strict);\n      }\n      function isIdentifierES6(id, strict) {\n        return isIdentifierName(id) && !isReservedWordES6(id, strict);\n      }\n      module.exports = {\n        isKeywordES5: isKeywordES5,\n        isKeywordES6: isKeywordES6,\n        isReservedWordES5: isReservedWordES5,\n        isReservedWordES6: isReservedWordES6,\n        isRestrictedWord: isRestrictedWord,\n        isIdentifierName: isIdentifierName,\n        isIdentifierES5: isIdentifierES5,\n        isIdentifierES6: isIdentifierES6\n      };\n    }());\n  });\n  require.define('/node_modules/esutils/lib/code.js', function (module, exports, __dirname, __filename) {\n    (function () {\n      'use strict';\n      var Regex, NON_ASCII_WHITESPACES;\n      Regex = {\n        NonAsciiIdentifierStart: new RegExp('[\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0370-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u048A-\\u0527\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0620-\\u064A\\u066E\\u066F\\u0671-\\u06D3\\u06D5\\u06E5\\u06E6\\u06EE\\u06EF\\u06FA-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07CA-\\u07EA\\u07F4\\u07F5\\u07FA\\u0800-\\u0815\\u081A\\u0824\\u0828\\u0840-\\u0858\\u08A0\\u08A2-\\u08AC\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0971-\\u0977\\u0979-\\u097F\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC\\u09DD\\u09DF-\\u09E1\\u09F0\\u09F1\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0\\u0AE1\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B71\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C33\\u0C35-\\u0C39\\u0C3D\\u0C58\\u0C59\\u0C60\\u0C61\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDE\\u0CE0\\u0CE1\\u0CF1\\u0CF2\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D\\u0D4E\\u0D60\\u0D61\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0E01-\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E46\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EDC-\\u0EDF\\u0F00\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8C\\u1000-\\u102A\\u103F\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1380-\\u138F\\u13A0-\\u13F4\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F0\\u1700-\\u170C\\u170E-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17D7\\u17DC\\u1820-\\u1877\\u1880-\\u18A8\\u18AA\\u18B0-\\u18F5\\u1900-\\u191C\\u1950-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19C1-\\u19C7\\u1A00-\\u1A16\\u1A20-\\u1A54\\u1AA7\\u1B05-\\u1B33\\u1B45-\\u1B4B\\u1B83-\\u1BA0\\u1BAE\\u1BAF\\u1BBA-\\u1BE5\\u1C00-\\u1C23\\u1C4D-\\u1C4F\\u1C5A-\\u1C7D\\u1CE9-\\u1CEC\\u1CEE-\\u1CF1\\u1CF5\\u1CF6\\u1D00-\\u1DBF\\u1E00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2071\\u207F\\u2090-\\u209C\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CEE\\u2CF2\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2E2F\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FCC\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA61F\\uA62A\\uA62B\\uA640-\\uA66E\\uA67F-\\uA697\\uA6A0-\\uA6EF\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA78E\\uA790-\\uA793\\uA7A0-\\uA7AA\\uA7F8-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA8F2-\\uA8F7\\uA8FB\\uA90A-\\uA925\\uA930-\\uA946\\uA960-\\uA97C\\uA984-\\uA9B2\\uA9CF\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAA60-\\uAA76\\uAA7A\\uAA80-\\uAAAF\\uAAB1\\uAAB5\\uAAB6\\uAAB9-\\uAABD\\uAAC0\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEA\\uAAF2-\\uAAF4\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uABC0-\\uABE2\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF21-\\uFF3A\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]'),\n        NonAsciiIdentifierPart: new RegExp('[\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0300-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u0483-\\u0487\\u048A-\\u0527\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0610-\\u061A\\u0620-\\u0669\\u066E-\\u06D3\\u06D5-\\u06DC\\u06DF-\\u06E8\\u06EA-\\u06FC\\u06FF\\u0710-\\u074A\\u074D-\\u07B1\\u07C0-\\u07F5\\u07FA\\u0800-\\u082D\\u0840-\\u085B\\u08A0\\u08A2-\\u08AC\\u08E4-\\u08FE\\u0900-\\u0963\\u0966-\\u096F\\u0971-\\u0977\\u0979-\\u097F\\u0981-\\u0983\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BC-\\u09C4\\u09C7\\u09C8\\u09CB-\\u09CE\\u09D7\\u09DC\\u09DD\\u09DF-\\u09E3\\u09E6-\\u09F1\\u0A01-\\u0A03\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A3C\\u0A3E-\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A59-\\u0A5C\\u0A5E\\u0A66-\\u0A75\\u0A81-\\u0A83\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABC-\\u0AC5\\u0AC7-\\u0AC9\\u0ACB-\\u0ACD\\u0AD0\\u0AE0-\\u0AE3\\u0AE6-\\u0AEF\\u0B01-\\u0B03\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3C-\\u0B44\\u0B47\\u0B48\\u0B4B-\\u0B4D\\u0B56\\u0B57\\u0B5C\\u0B5D\\u0B5F-\\u0B63\\u0B66-\\u0B6F\\u0B71\\u0B82\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BBE-\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCD\\u0BD0\\u0BD7\\u0BE6-\\u0BEF\\u0C01-\\u0C03\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C33\\u0C35-\\u0C39\\u0C3D-\\u0C44\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C58\\u0C59\\u0C60-\\u0C63\\u0C66-\\u0C6F\\u0C82\\u0C83\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBC-\\u0CC4\\u0CC6-\\u0CC8\\u0CCA-\\u0CCD\\u0CD5\\u0CD6\\u0CDE\\u0CE0-\\u0CE3\\u0CE6-\\u0CEF\\u0CF1\\u0CF2\\u0D02\\u0D03\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D-\\u0D44\\u0D46-\\u0D48\\u0D4A-\\u0D4E\\u0D57\\u0D60-\\u0D63\\u0D66-\\u0D6F\\u0D7A-\\u0D7F\\u0D82\\u0D83\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0DCA\\u0DCF-\\u0DD4\\u0DD6\\u0DD8-\\u0DDF\\u0DF2\\u0DF3\\u0E01-\\u0E3A\\u0E40-\\u0E4E\\u0E50-\\u0E59\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB9\\u0EBB-\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EC8-\\u0ECD\\u0ED0-\\u0ED9\\u0EDC-\\u0EDF\\u0F00\\u0F18\\u0F19\\u0F20-\\u0F29\\u0F35\\u0F37\\u0F39\\u0F3E-\\u0F47\\u0F49-\\u0F6C\\u0F71-\\u0F84\\u0F86-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u1000-\\u1049\\u1050-\\u109D\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u135D-\\u135F\\u1380-\\u138F\\u13A0-\\u13F4\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F0\\u1700-\\u170C\\u170E-\\u1714\\u1720-\\u1734\\u1740-\\u1753\\u1760-\\u176C\\u176E-\\u1770\\u1772\\u1773\\u1780-\\u17D3\\u17D7\\u17DC\\u17DD\\u17E0-\\u17E9\\u180B-\\u180D\\u1810-\\u1819\\u1820-\\u1877\\u1880-\\u18AA\\u18B0-\\u18F5\\u1900-\\u191C\\u1920-\\u192B\\u1930-\\u193B\\u1946-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u19D0-\\u19D9\\u1A00-\\u1A1B\\u1A20-\\u1A5E\\u1A60-\\u1A7C\\u1A7F-\\u1A89\\u1A90-\\u1A99\\u1AA7\\u1B00-\\u1B4B\\u1B50-\\u1B59\\u1B6B-\\u1B73\\u1B80-\\u1BF3\\u1C00-\\u1C37\\u1C40-\\u1C49\\u1C4D-\\u1C7D\\u1CD0-\\u1CD2\\u1CD4-\\u1CF6\\u1D00-\\u1DE6\\u1DFC-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u200C\\u200D\\u203F\\u2040\\u2054\\u2071\\u207F\\u2090-\\u209C\\u20D0-\\u20DC\\u20E1\\u20E5-\\u20F0\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D7F-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2DE0-\\u2DFF\\u2E2F\\u3005-\\u3007\\u3021-\\u302F\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u3099\\u309A\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FCC\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA62B\\uA640-\\uA66F\\uA674-\\uA67D\\uA67F-\\uA697\\uA69F-\\uA6F1\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA78E\\uA790-\\uA793\\uA7A0-\\uA7AA\\uA7F8-\\uA827\\uA840-\\uA873\\uA880-\\uA8C4\\uA8D0-\\uA8D9\\uA8E0-\\uA8F7\\uA8FB\\uA900-\\uA92D\\uA930-\\uA953\\uA960-\\uA97C\\uA980-\\uA9C0\\uA9CF-\\uA9D9\\uAA00-\\uAA36\\uAA40-\\uAA4D\\uAA50-\\uAA59\\uAA60-\\uAA76\\uAA7A\\uAA7B\\uAA80-\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEF\\uAAF2-\\uAAF6\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uABC0-\\uABEA\\uABEC\\uABED\\uABF0-\\uABF9\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE00-\\uFE0F\\uFE20-\\uFE26\\uFE33\\uFE34\\uFE4D-\\uFE4F\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF10-\\uFF19\\uFF21-\\uFF3A\\uFF3F\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]')\n      };\n      function isDecimalDigit(ch) {\n        return ch >= 48 && ch <= 57;\n      }\n      function isHexDigit(ch) {\n        return isDecimalDigit(ch) || 97 <= ch && ch <= 102 || 65 <= ch && ch <= 70;\n      }\n      function isOctalDigit(ch) {\n        return ch >= 48 && ch <= 55;\n      }\n      NON_ASCII_WHITESPACES = [\n        5760,\n        6158,\n        8192,\n        8193,\n        8194,\n        8195,\n        8196,\n        8197,\n        8198,\n        8199,\n        8200,\n        8201,\n        8202,\n        8239,\n        8287,\n        12288,\n        65279\n      ];\n      function isWhiteSpace(ch) {\n        return ch === 32 || ch === 9 || ch === 11 || ch === 12 || ch === 160 || ch >= 5760 && NON_ASCII_WHITESPACES.indexOf(ch) >= 0;\n      }\n      function isLineTerminator(ch) {\n        return ch === 10 || ch === 13 || ch === 8232 || ch === 8233;\n      }\n      function isIdentifierStart(ch) {\n        return ch >= 97 && ch <= 122 || ch >= 65 && ch <= 90 || ch === 36 || ch === 95 || ch === 92 || ch >= 128 && Regex.NonAsciiIdentifierStart.test(String.fromCharCode(ch));\n      }\n      function isIdentifierPart(ch) {\n        return ch >= 97 && ch <= 122 || ch >= 65 && ch <= 90 || ch >= 48 && ch <= 57 || ch === 36 || ch === 95 || ch === 92 || ch >= 128 && Regex.NonAsciiIdentifierPart.test(String.fromCharCode(ch));\n      }\n      module.exports = {\n        isDecimalDigit: isDecimalDigit,\n        isHexDigit: isHexDigit,\n        isOctalDigit: isOctalDigit,\n        isWhiteSpace: isWhiteSpace,\n        isLineTerminator: isLineTerminator,\n        isIdentifierStart: isIdentifierStart,\n        isIdentifierPart: isIdentifierPart\n      };\n    }());\n  });\n  require.define('/node_modules/esutils/lib/ast.js', function (module, exports, __dirname, __filename) {\n    (function () {\n      'use strict';\n      function isExpression(node) {\n        if (node == null) {\n          return false;\n        }\n        switch (node.type) {\n        case 'ArrayExpression':\n        case 'AssignmentExpression':\n        case 'BinaryExpression':\n        case 'CallExpression':\n        case 'ConditionalExpression':\n        case 'FunctionExpression':\n        case 'Identifier':\n        case 'Literal':\n        case 'LogicalExpression':\n        case 'MemberExpression':\n        case 'NewExpression':\n        case 'ObjectExpression':\n        case 'SequenceExpression':\n        case 'ThisExpression':\n        case 'UnaryExpression':\n        case 'UpdateExpression':\n          return true;\n        }\n        return false;\n      }\n      function isIterationStatement(node) {\n        if (node == null) {\n          return false;\n        }\n        switch (node.type) {\n        case 'DoWhileStatement':\n        case 'ForInStatement':\n        case 'ForStatement':\n        case 'WhileStatement':\n          return true;\n        }\n        return false;\n      }\n      function isStatement(node) {\n        if (node == null) {\n          return false;\n        }\n        switch (node.type) {\n        case 'BlockStatement':\n        case 'BreakStatement':\n        case 'ContinueStatement':\n        case 'DebuggerStatement':\n        case 'DoWhileStatement':\n        case 'EmptyStatement':\n        case 'ExpressionStatement':\n        case 'ForInStatement':\n        case 'ForStatement':\n        case 'IfStatement':\n        case 'LabeledStatement':\n        case 'ReturnStatement':\n        case 'SwitchStatement':\n        case 'ThrowStatement':\n        case 'TryStatement':\n        case 'VariableDeclaration':\n        case 'WhileStatement':\n        case 'WithStatement':\n          return true;\n        }\n        return false;\n      }\n      function isSourceElement(node) {\n        return isStatement(node) || node != null && node.type === 'FunctionDeclaration';\n      }\n      function trailingStatement(node) {\n        switch (node.type) {\n        case 'IfStatement':\n          if (node.alternate != null) {\n            return node.alternate;\n          }\n          return node.consequent;\n        case 'LabeledStatement':\n        case 'ForStatement':\n        case 'ForInStatement':\n        case 'WhileStatement':\n        case 'WithStatement':\n          return node.body;\n        }\n        return null;\n      }\n      function isProblematicIfStatement(node) {\n        var current;\n        if (node.type !== 'IfStatement') {\n          return false;\n        }\n        if (node.alternate == null) {\n          return false;\n        }\n        current = node.consequent;\n        do {\n          if (current.type === 'IfStatement') {\n            if (current.alternate == null) {\n              return true;\n            }\n          }\n          current = trailingStatement(current);\n        } while (current);\n        return false;\n      }\n      module.exports = {\n        isExpression: isExpression,\n        isStatement: isStatement,\n        isIterationStatement: isIterationStatement,\n        isSourceElement: isSourceElement,\n        isProblematicIfStatement: isProblematicIfStatement,\n        trailingStatement: trailingStatement\n      };\n    }());\n  });\n  require.define('/node_modules/estraverse/estraverse.js', function (module, exports, __dirname, __filename) {\n    (function (root, factory) {\n      'use strict';\n      if (typeof define === 'function' && define.amd) {\n        define(['exports'], factory);\n      } else if (typeof exports !== 'undefined') {\n        factory(exports);\n      } else {\n        factory(root.estraverse = {});\n      }\n    }(this, function (exports) {\n      'use strict';\n      var Syntax, isArray, VisitorOption, VisitorKeys, objectCreate, objectKeys, BREAK, SKIP, REMOVE;\n      function ignoreJSHintError() {\n      }\n      isArray = Array.isArray;\n      if (!isArray) {\n        isArray = function isArray(array) {\n          return Object.prototype.toString.call(array) === '[object Array]';\n        };\n      }\n      function deepCopy(obj) {\n        var ret = {}, key, val;\n        for (key in obj) {\n          if (obj.hasOwnProperty(key)) {\n            val = obj[key];\n            if (typeof val === 'object' && val !== null) {\n              ret[key] = deepCopy(val);\n            } else {\n              ret[key] = val;\n            }\n          }\n        }\n        return ret;\n      }\n      function shallowCopy(obj) {\n        var ret = {}, key;\n        for (key in obj) {\n          if (obj.hasOwnProperty(key)) {\n            ret[key] = obj[key];\n          }\n        }\n        return ret;\n      }\n      ignoreJSHintError(shallowCopy);\n      function upperBound(array, func) {\n        var diff, len, i, current;\n        len = array.length;\n        i = 0;\n        while (len) {\n          diff = len >>> 1;\n          current = i + diff;\n          if (func(array[current])) {\n            len = diff;\n          } else {\n            i = current + 1;\n            len -= diff + 1;\n          }\n        }\n        return i;\n      }\n      function lowerBound(array, func) {\n        var diff, len, i, current;\n        len = array.length;\n        i = 0;\n        while (len) {\n          diff = len >>> 1;\n          current = i + diff;\n          if (func(array[current])) {\n            i = current + 1;\n            len -= diff + 1;\n          } else {\n            len = diff;\n          }\n        }\n        return i;\n      }\n      ignoreJSHintError(lowerBound);\n      objectCreate = Object.create || function () {\n        function F() {\n        }\n        return function (o) {\n          F.prototype = o;\n          return new F;\n        };\n      }();\n      objectKeys = Object.keys || function (o) {\n        var keys = [], key;\n        for (key in o) {\n          keys.push(key);\n        }\n        return keys;\n      };\n      function extend(to, from) {\n        objectKeys(from).forEach(function (key) {\n          to[key] = from[key];\n        });\n        return to;\n      }\n      Syntax = {\n        AssignmentExpression: 'AssignmentExpression',\n        ArrayExpression: 'ArrayExpression',\n        ArrayPattern: 'ArrayPattern',\n        ArrowFunctionExpression: 'ArrowFunctionExpression',\n        AwaitExpression: 'AwaitExpression',\n        BlockStatement: 'BlockStatement',\n        BinaryExpression: 'BinaryExpression',\n        BreakStatement: 'BreakStatement',\n        CallExpression: 'CallExpression',\n        CatchClause: 'CatchClause',\n        ClassBody: 'ClassBody',\n        ClassDeclaration: 'ClassDeclaration',\n        ClassExpression: 'ClassExpression',\n        ComprehensionBlock: 'ComprehensionBlock',\n        ComprehensionExpression: 'ComprehensionExpression',\n        ConditionalExpression: 'ConditionalExpression',\n        ContinueStatement: 'ContinueStatement',\n        DebuggerStatement: 'DebuggerStatement',\n        DirectiveStatement: 'DirectiveStatement',\n        DoWhileStatement: 'DoWhileStatement',\n        EmptyStatement: 'EmptyStatement',\n        ExportBatchSpecifier: 'ExportBatchSpecifier',\n        ExportDeclaration: 'ExportDeclaration',\n        ExportSpecifier: 'ExportSpecifier',\n        ExpressionStatement: 'ExpressionStatement',\n        ForStatement: 'ForStatement',\n        ForInStatement: 'ForInStatement',\n        ForOfStatement: 'ForOfStatement',\n        FunctionDeclaration: 'FunctionDeclaration',\n        FunctionExpression: 'FunctionExpression',\n        GeneratorExpression: 'GeneratorExpression',\n        Identifier: 'Identifier',\n        IfStatement: 'IfStatement',\n        ImportDeclaration: 'ImportDeclaration',\n        ImportDefaultSpecifier: 'ImportDefaultSpecifier',\n        ImportNamespaceSpecifier: 'ImportNamespaceSpecifier',\n        ImportSpecifier: 'ImportSpecifier',\n        Literal: 'Literal',\n        LabeledStatement: 'LabeledStatement',\n        LogicalExpression: 'LogicalExpression',\n        MemberExpression: 'MemberExpression',\n        MethodDefinition: 'MethodDefinition',\n        ModuleSpecifier: 'ModuleSpecifier',\n        NewExpression: 'NewExpression',\n        ObjectExpression: 'ObjectExpression',\n        ObjectPattern: 'ObjectPattern',\n        Program: 'Program',\n        Property: 'Property',\n        ReturnStatement: 'ReturnStatement',\n        SequenceExpression: 'SequenceExpression',\n        SpreadElement: 'SpreadElement',\n        SwitchStatement: 'SwitchStatement',\n        SwitchCase: 'SwitchCase',\n        TaggedTemplateExpression: 'TaggedTemplateExpression',\n        TemplateElement: 'TemplateElement',\n        TemplateLiteral: 'TemplateLiteral',\n        ThisExpression: 'ThisExpression',\n        ThrowStatement: 'ThrowStatement',\n        TryStatement: 'TryStatement',\n        UnaryExpression: 'UnaryExpression',\n        UpdateExpression: 'UpdateExpression',\n        VariableDeclaration: 'VariableDeclaration',\n        VariableDeclarator: 'VariableDeclarator',\n        WhileStatement: 'WhileStatement',\n        WithStatement: 'WithStatement',\n        YieldExpression: 'YieldExpression'\n      };\n      VisitorKeys = {\n        AssignmentExpression: [\n          'left',\n          'right'\n        ],\n        ArrayExpression: ['elements'],\n        ArrayPattern: ['elements'],\n        ArrowFunctionExpression: [\n          'params',\n          'defaults',\n          'rest',\n          'body'\n        ],\n        AwaitExpression: ['argument'],\n        BlockStatement: ['body'],\n        BinaryExpression: [\n          'left',\n          'right'\n        ],\n        BreakStatement: ['label'],\n        CallExpression: [\n          'callee',\n          'arguments'\n        ],\n        CatchClause: [\n          'param',\n          'body'\n        ],\n        ClassBody: ['body'],\n        ClassDeclaration: [\n          'id',\n          'body',\n          'superClass'\n        ],\n        ClassExpression: [\n          'id',\n          'body',\n          'superClass'\n        ],\n        ComprehensionBlock: [\n          'left',\n          'right'\n        ],\n        ComprehensionExpression: [\n          'blocks',\n          'filter',\n          'body'\n        ],\n        ConditionalExpression: [\n          'test',\n          'consequent',\n          'alternate'\n        ],\n        ContinueStatement: ['label'],\n        DebuggerStatement: [],\n        DirectiveStatement: [],\n        DoWhileStatement: [\n          'body',\n          'test'\n        ],\n        EmptyStatement: [],\n        ExportBatchSpecifier: [],\n        ExportDeclaration: [\n          'declaration',\n          'specifiers',\n          'source'\n        ],\n        ExportSpecifier: [\n          'id',\n          'name'\n        ],\n        ExpressionStatement: ['expression'],\n        ForStatement: [\n          'init',\n          'test',\n          'update',\n          'body'\n        ],\n        ForInStatement: [\n          'left',\n          'right',\n          'body'\n        ],\n        ForOfStatement: [\n          'left',\n          'right',\n          'body'\n        ],\n        FunctionDeclaration: [\n          'id',\n          'params',\n          'defaults',\n          'rest',\n          'body'\n        ],\n        FunctionExpression: [\n          'id',\n          'params',\n          'defaults',\n          'rest',\n          'body'\n        ],\n        GeneratorExpression: [\n          'blocks',\n          'filter',\n          'body'\n        ],\n        Identifier: [],\n        IfStatement: [\n          'test',\n          'consequent',\n          'alternate'\n        ],\n        ImportDeclaration: [\n          'specifiers',\n          'source'\n        ],\n        ImportDefaultSpecifier: ['id'],\n        ImportNamespaceSpecifier: ['id'],\n        ImportSpecifier: [\n          'id',\n          'name'\n        ],\n        Literal: [],\n        LabeledStatement: [\n          'label',\n          'body'\n        ],\n        LogicalExpression: [\n          'left',\n          'right'\n        ],\n        MemberExpression: [\n          'object',\n          'property'\n        ],\n        MethodDefinition: [\n          'key',\n          'value'\n        ],\n        ModuleSpecifier: [],\n        NewExpression: [\n          'callee',\n          'arguments'\n        ],\n        ObjectExpression: ['properties'],\n        ObjectPattern: ['properties'],\n        Program: ['body'],\n        Property: [\n          'key',\n          'value'\n        ],\n        ReturnStatement: ['argument'],\n        SequenceExpression: ['expressions'],\n        SpreadElement: ['argument'],\n        SwitchStatement: [\n          'discriminant',\n          'cases'\n        ],\n        SwitchCase: [\n          'test',\n          'consequent'\n        ],\n        TaggedTemplateExpression: [\n          'tag',\n          'quasi'\n        ],\n        TemplateElement: [],\n        TemplateLiteral: [\n          'quasis',\n          'expressions'\n        ],\n        ThisExpression: [],\n        ThrowStatement: ['argument'],\n        TryStatement: [\n          'block',\n          'handlers',\n          'handler',\n          'guardedHandlers',\n          'finalizer'\n        ],\n        UnaryExpression: ['argument'],\n        UpdateExpression: ['argument'],\n        VariableDeclaration: ['declarations'],\n        VariableDeclarator: [\n          'id',\n          'init'\n        ],\n        WhileStatement: [\n          'test',\n          'body'\n        ],\n        WithStatement: [\n          'object',\n          'body'\n        ],\n        YieldExpression: ['argument']\n      };\n      BREAK = {};\n      SKIP = {};\n      REMOVE = {};\n      VisitorOption = {\n        Break: BREAK,\n        Skip: SKIP,\n        Remove: REMOVE\n      };\n      function Reference(parent, key) {\n        this.parent = parent;\n        this.key = key;\n      }\n      Reference.prototype.replace = function replace(node) {\n        this.parent[this.key] = node;\n      };\n      Reference.prototype.remove = function remove() {\n        if (isArray(this.parent)) {\n          this.parent.splice(this.key, 1);\n          return true;\n        } else {\n          this.replace(null);\n          return false;\n        }\n      };\n      function Element(node, path, wrap, ref) {\n        this.node = node;\n        this.path = path;\n        this.wrap = wrap;\n        this.ref = ref;\n      }\n      function Controller() {\n      }\n      Controller.prototype.path = function path() {\n        var i, iz, j, jz, result, element;\n        function addToPath(result, path) {\n          if (isArray(path)) {\n            for (j = 0, jz = path.length; j < jz; ++j) {\n              result.push(path[j]);\n            }\n          } else {\n            result.push(path);\n          }\n        }\n        if (!this.__current.path) {\n          return null;\n        }\n        result = [];\n        for (i = 2, iz = this.__leavelist.length; i < iz; ++i) {\n          element = this.__leavelist[i];\n          addToPath(result, element.path);\n        }\n        addToPath(result, this.__current.path);\n        return result;\n      };\n      Controller.prototype.type = function () {\n        var node = this.current();\n        return node.type || this.__current.wrap;\n      };\n      Controller.prototype.parents = function parents() {\n        var i, iz, result;\n        result = [];\n        for (i = 1, iz = this.__leavelist.length; i < iz; ++i) {\n          result.push(this.__leavelist[i].node);\n        }\n        return result;\n      };\n      Controller.prototype.current = function current() {\n        return this.__current.node;\n      };\n      Controller.prototype.__execute = function __execute(callback, element) {\n        var previous, result;\n        result = undefined;\n        previous = this.__current;\n        this.__current = element;\n        this.__state = null;\n        if (callback) {\n          result = callback.call(this, element.node, this.__leavelist[this.__leavelist.length - 1].node);\n        }\n        this.__current = previous;\n        return result;\n      };\n      Controller.prototype.notify = function notify(flag) {\n        this.__state = flag;\n      };\n      Controller.prototype.skip = function () {\n        this.notify(SKIP);\n      };\n      Controller.prototype['break'] = function () {\n        this.notify(BREAK);\n      };\n      Controller.prototype.remove = function () {\n        this.notify(REMOVE);\n      };\n      Controller.prototype.__initialize = function (root, visitor) {\n        this.visitor = visitor;\n        this.root = root;\n        this.__worklist = [];\n        this.__leavelist = [];\n        this.__current = null;\n        this.__state = null;\n        this.__fallback = visitor.fallback === 'iteration';\n        this.__keys = VisitorKeys;\n        if (visitor.keys) {\n          this.__keys = extend(objectCreate(this.__keys), visitor.keys);\n        }\n      };\n      function isNode(node) {\n        if (node == null) {\n          return false;\n        }\n        return typeof node === 'object' && typeof node.type === 'string';\n      }\n      function isProperty(nodeType, key) {\n        return (nodeType === Syntax.ObjectExpression || nodeType === Syntax.ObjectPattern) && 'properties' === key;\n      }\n      Controller.prototype.traverse = function traverse(root, visitor) {\n        var worklist, leavelist, element, node, nodeType, ret, key, current, current2, candidates, candidate, sentinel;\n        this.__initialize(root, visitor);\n        sentinel = {};\n        worklist = this.__worklist;\n        leavelist = this.__leavelist;\n        worklist.push(new Element(root, null, null, null));\n        leavelist.push(new Element(null, null, null, null));\n        while (worklist.length) {\n          element = worklist.pop();\n          if (element === sentinel) {\n            element = leavelist.pop();\n            ret = this.__execute(visitor.leave, element);\n            if (this.__state === BREAK || ret === BREAK) {\n              return;\n            }\n            continue;\n          }\n          if (element.node) {\n            ret = this.__execute(visitor.enter, element);\n            if (this.__state === BREAK || ret === BREAK) {\n              return;\n            }\n            worklist.push(sentinel);\n            leavelist.push(element);\n            if (this.__state === SKIP || ret === SKIP) {\n              continue;\n            }\n            node = element.node;\n            nodeType = element.wrap || node.type;\n            candidates = this.__keys[nodeType];\n            if (!candidates) {\n              if (this.__fallback) {\n                candidates = objectKeys(node);\n              } else {\n                throw new Error('Unknown node type ' + nodeType + '.');\n              }\n            }\n            current = candidates.length;\n            while ((current -= 1) >= 0) {\n              key = candidates[current];\n              candidate = node[key];\n              if (!candidate) {\n                continue;\n              }\n              if (isArray(candidate)) {\n                current2 = candidate.length;\n                while ((current2 -= 1) >= 0) {\n                  if (!candidate[current2]) {\n                    continue;\n                  }\n                  if (isProperty(nodeType, candidates[current])) {\n                    element = new Element(candidate[current2], [\n                      key,\n                      current2\n                    ], 'Property', null);\n                  } else if (isNode(candidate[current2])) {\n                    element = new Element(candidate[current2], [\n                      key,\n                      current2\n                    ], null, null);\n                  } else {\n                    continue;\n                  }\n                  worklist.push(element);\n                }\n              } else if (isNode(candidate)) {\n                worklist.push(new Element(candidate, key, null, null));\n              }\n            }\n          }\n        }\n      };\n      Controller.prototype.replace = function replace(root, visitor) {\n        function removeElem(element) {\n          var i, key, nextElem, parent;\n          if (element.ref.remove()) {\n            key = element.ref.key;\n            parent = element.ref.parent;\n            i = worklist.length;\n            while (i--) {\n              nextElem = worklist[i];\n              if (nextElem.ref && nextElem.ref.parent === parent) {\n                if (nextElem.ref.key < key) {\n                  break;\n                }\n                --nextElem.ref.key;\n              }\n            }\n          }\n        }\n        var worklist, leavelist, node, nodeType, target, element, current, current2, candidates, candidate, sentinel, outer, key;\n        this.__initialize(root, visitor);\n        sentinel = {};\n        worklist = this.__worklist;\n        leavelist = this.__leavelist;\n        outer = { root: root };\n        element = new Element(root, null, null, new Reference(outer, 'root'));\n        worklist.push(element);\n        leavelist.push(element);\n        while (worklist.length) {\n          element = worklist.pop();\n          if (element === sentinel) {\n            element = leavelist.pop();\n            target = this.__execute(visitor.leave, element);\n            if (target !== undefined && target !== BREAK && target !== SKIP && target !== REMOVE) {\n              element.ref.replace(target);\n            }\n            if (this.__state === REMOVE || target === REMOVE) {\n              removeElem(element);\n            }\n            if (this.__state === BREAK || target === BREAK) {\n              return outer.root;\n            }\n            continue;\n          }\n          target = this.__execute(visitor.enter, element);\n          if (target !== undefined && target !== BREAK && target !== SKIP && target !== REMOVE) {\n            element.ref.replace(target);\n            element.node = target;\n          }\n          if (this.__state === REMOVE || target === REMOVE) {\n            removeElem(element);\n            element.node = null;\n          }\n          if (this.__state === BREAK || target === BREAK) {\n            return outer.root;\n          }\n          node = element.node;\n          if (!node) {\n            continue;\n          }\n          worklist.push(sentinel);\n          leavelist.push(element);\n          if (this.__state === SKIP || target === SKIP) {\n            continue;\n          }\n          nodeType = element.wrap || node.type;\n          candidates = this.__keys[nodeType];\n          if (!candidates) {\n            if (this.__fallback) {\n              candidates = objectKeys(node);\n            } else {\n              throw new Error('Unknown node type ' + nodeType + '.');\n            }\n          }\n          current = candidates.length;\n          while ((current -= 1) >= 0) {\n            key = candidates[current];\n            candidate = node[key];\n            if (!candidate) {\n              continue;\n            }\n            if (isArray(candidate)) {\n              current2 = candidate.length;\n              while ((current2 -= 1) >= 0) {\n                if (!candidate[current2]) {\n                  continue;\n                }\n                if (isProperty(nodeType, candidates[current])) {\n                  element = new Element(candidate[current2], [\n                    key,\n                    current2\n                  ], 'Property', new Reference(candidate, current2));\n                } else if (isNode(candidate[current2])) {\n                  element = new Element(candidate[current2], [\n                    key,\n                    current2\n                  ], null, new Reference(candidate, current2));\n                } else {\n                  continue;\n                }\n                worklist.push(element);\n              }\n            } else if (isNode(candidate)) {\n              worklist.push(new Element(candidate, key, null, new Reference(node, key)));\n            }\n          }\n        }\n        return outer.root;\n      };\n      function traverse(root, visitor) {\n        var controller = new Controller;\n        return controller.traverse(root, visitor);\n      }\n      function replace(root, visitor) {\n        var controller = new Controller;\n        return controller.replace(root, visitor);\n      }\n      function extendCommentRange(comment, tokens) {\n        var target;\n        target = upperBound(tokens, function search(token) {\n          return token.range[0] > comment.range[0];\n        });\n        comment.extendedRange = [\n          comment.range[0],\n          comment.range[1]\n        ];\n        if (target !== tokens.length) {\n          comment.extendedRange[1] = tokens[target].range[0];\n        }\n        target -= 1;\n        if (target >= 0) {\n          comment.extendedRange[0] = tokens[target].range[1];\n        }\n        return comment;\n      }\n      function attachComments(tree, providedComments, tokens) {\n        var comments = [], comment, len, i, cursor;\n        if (!tree.range) {\n          throw new Error('attachComments needs range information');\n        }\n        if (!tokens.length) {\n          if (providedComments.length) {\n            for (i = 0, len = providedComments.length; i < len; i += 1) {\n              comment = deepCopy(providedComments[i]);\n              comment.extendedRange = [\n                0,\n                tree.range[0]\n              ];\n              comments.push(comment);\n            }\n            tree.leadingComments = comments;\n          }\n          return tree;\n        }\n        for (i = 0, len = providedComments.length; i < len; i += 1) {\n          comments.push(extendCommentRange(deepCopy(providedComments[i]), tokens));\n        }\n        cursor = 0;\n        traverse(tree, {\n          enter: function (node) {\n            var comment;\n            while (cursor < comments.length) {\n              comment = comments[cursor];\n              if (comment.extendedRange[1] > node.range[0]) {\n                break;\n              }\n              if (comment.extendedRange[1] === node.range[0]) {\n                if (!node.leadingComments) {\n                  node.leadingComments = [];\n                }\n                node.leadingComments.push(comment);\n                comments.splice(cursor, 1);\n              } else {\n                cursor += 1;\n              }\n            }\n            if (cursor === comments.length) {\n              return VisitorOption.Break;\n            }\n            if (comments[cursor].extendedRange[0] > node.range[1]) {\n              return VisitorOption.Skip;\n            }\n          }\n        });\n        cursor = 0;\n        traverse(tree, {\n          leave: function (node) {\n            var comment;\n            while (cursor < comments.length) {\n              comment = comments[cursor];\n              if (node.range[1] < comment.extendedRange[0]) {\n                break;\n              }\n              if (node.range[1] === comment.extendedRange[0]) {\n                if (!node.trailingComments) {\n                  node.trailingComments = [];\n                }\n                node.trailingComments.push(comment);\n                comments.splice(cursor, 1);\n              } else {\n                cursor += 1;\n              }\n            }\n            if (cursor === comments.length) {\n              return VisitorOption.Break;\n            }\n            if (comments[cursor].extendedRange[0] > node.range[1]) {\n              return VisitorOption.Skip;\n            }\n          }\n        });\n        return tree;\n      }\n      exports.version = '1.8.1-dev';\n      exports.Syntax = Syntax;\n      exports.traverse = traverse;\n      exports.replace = replace;\n      exports.attachComments = attachComments;\n      exports.VisitorKeys = VisitorKeys;\n      exports.VisitorOption = VisitorOption;\n      exports.Controller = Controller;\n    }));\n  });\n  require('/tools/entry-point.js');\n}.call(this, this));\n","esprima":"/*\n  Copyright (C) 2013 Ariya Hidayat <ariya.hidayat@gmail.com>\n  Copyright (C) 2013 Thaddee Tyl <thaddee.tyl@gmail.com>\n  Copyright (C) 2012 Ariya Hidayat <ariya.hidayat@gmail.com>\n  Copyright (C) 2012 Mathias Bynens <mathias@qiwi.be>\n  Copyright (C) 2012 Joost-Wim Boekesteijn <joost-wim@boekesteijn.nl>\n  Copyright (C) 2012 Kris Kowal <kris.kowal@cixar.com>\n  Copyright (C) 2012 Yusuke Suzuki <utatane.tea@gmail.com>\n  Copyright (C) 2012 Arpad Borsos <arpad.borsos@googlemail.com>\n  Copyright (C) 2011 Ariya Hidayat <ariya.hidayat@gmail.com>\n\n  Redistribution and use in source and binary forms, with or without\n  modification, are permitted provided that the following conditions are met:\n\n    * Redistributions of source code must retain the above copyright\n      notice, this list of conditions and the following disclaimer.\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in the\n      documentation and/or other materials provided with the distribution.\n\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\n  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n/*jslint bitwise:true plusplus:true */\n/*global esprima:true, define:true, exports:true, window: true,\ncreateLocationMarker: true,\nthrowError: true, generateStatement: true, peek: true,\nparseAssignmentExpression: true, parseBlock: true, parseExpression: true,\nparseFunctionDeclaration: true, parseFunctionExpression: true,\nparseFunctionSourceElements: true, parseVariableIdentifier: true,\nparseLeftHandSideExpression: true,\nparseUnaryExpression: true,\nparseStatement: true, parseSourceElement: true */\n\n(function (root, factory) {\n    'use strict';\n\n    // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js,\n    // Rhino, and plain browser loading.\n    if (typeof define === 'function' && define.amd) {\n        define(['exports'], factory);\n    } else if (typeof exports !== 'undefined') {\n        factory(exports);\n    } else {\n        factory((root.esprima = {}));\n    }\n}(this, function (exports) {\n    'use strict';\n\n    var Token,\n        TokenName,\n        FnExprTokens,\n        Syntax,\n        PropertyKind,\n        Messages,\n        Regex,\n        SyntaxTreeDelegate,\n        source,\n        strict,\n        index,\n        lineNumber,\n        lineStart,\n        length,\n        delegate,\n        lookahead,\n        state,\n        extra;\n\n    Token = {\n        BooleanLiteral: 1,\n        EOF: 2,\n        Identifier: 3,\n        Keyword: 4,\n        NullLiteral: 5,\n        NumericLiteral: 6,\n        Punctuator: 7,\n        StringLiteral: 8,\n        RegularExpression: 9\n    };\n\n    TokenName = {};\n    TokenName[Token.BooleanLiteral] = 'Boolean';\n    TokenName[Token.EOF] = '<end>';\n    TokenName[Token.Identifier] = 'Identifier';\n    TokenName[Token.Keyword] = 'Keyword';\n    TokenName[Token.NullLiteral] = 'Null';\n    TokenName[Token.NumericLiteral] = 'Numeric';\n    TokenName[Token.Punctuator] = 'Punctuator';\n    TokenName[Token.StringLiteral] = 'String';\n    TokenName[Token.RegularExpression] = 'RegularExpression';\n\n    // A function following one of those tokens is an expression.\n    FnExprTokens = ['(', '{', '[', 'in', 'typeof', 'instanceof', 'new',\n                    'return', 'case', 'delete', 'throw', 'void',\n                    // assignment operators\n                    '=', '+=', '-=', '*=', '/=', '%=', '<<=', '>>=', '>>>=',\n                    '&=', '|=', '^=', ',',\n                    // binary/unary operators\n                    '+', '-', '*', '/', '%', '++', '--', '<<', '>>', '>>>', '&',\n                    '|', '^', '!', '~', '&&', '||', '?', ':', '===', '==', '>=',\n                    '<=', '<', '>', '!=', '!=='];\n\n    Syntax = {\n        AssignmentExpression: 'AssignmentExpression',\n        ArrayExpression: 'ArrayExpression',\n        BlockStatement: 'BlockStatement',\n        BinaryExpression: 'BinaryExpression',\n        BreakStatement: 'BreakStatement',\n        CallExpression: 'CallExpression',\n        CatchClause: 'CatchClause',\n        ConditionalExpression: 'ConditionalExpression',\n        ContinueStatement: 'ContinueStatement',\n        DoWhileStatement: 'DoWhileStatement',\n        DebuggerStatement: 'DebuggerStatement',\n        EmptyStatement: 'EmptyStatement',\n        ExpressionStatement: 'ExpressionStatement',\n        ForStatement: 'ForStatement',\n        ForInStatement: 'ForInStatement',\n        FunctionDeclaration: 'FunctionDeclaration',\n        FunctionExpression: 'FunctionExpression',\n        Identifier: 'Identifier',\n        IfStatement: 'IfStatement',\n        Literal: 'Literal',\n        LabeledStatement: 'LabeledStatement',\n        LogicalExpression: 'LogicalExpression',\n        MemberExpression: 'MemberExpression',\n        NewExpression: 'NewExpression',\n        ObjectExpression: 'ObjectExpression',\n        Program: 'Program',\n        Property: 'Property',\n        ReturnStatement: 'ReturnStatement',\n        SequenceExpression: 'SequenceExpression',\n        SwitchStatement: 'SwitchStatement',\n        SwitchCase: 'SwitchCase',\n        ThisExpression: 'ThisExpression',\n        ThrowStatement: 'ThrowStatement',\n        TryStatement: 'TryStatement',\n        UnaryExpression: 'UnaryExpression',\n        UpdateExpression: 'UpdateExpression',\n        VariableDeclaration: 'VariableDeclaration',\n        VariableDeclarator: 'VariableDeclarator',\n        WhileStatement: 'WhileStatement',\n        WithStatement: 'WithStatement'\n    };\n\n    PropertyKind = {\n        Data: 1,\n        Get: 2,\n        Set: 4\n    };\n\n    // Error messages should be identical to V8.\n    Messages = {\n        UnexpectedToken:  'Unexpected token %0',\n        UnexpectedNumber:  'Unexpected number',\n        UnexpectedString:  'Unexpected string',\n        UnexpectedIdentifier:  'Unexpected identifier',\n        UnexpectedReserved:  'Unexpected reserved word',\n        UnexpectedEOS:  'Unexpected end of input',\n        NewlineAfterThrow:  'Illegal newline after throw',\n        InvalidRegExp: 'Invalid regular expression',\n        UnterminatedRegExp:  'Invalid regular expression: missing /',\n        InvalidLHSInAssignment:  'Invalid left-hand side in assignment',\n        InvalidLHSInForIn:  'Invalid left-hand side in for-in',\n        MultipleDefaultsInSwitch: 'More than one default clause in switch statement',\n        NoCatchOrFinally:  'Missing catch or finally after try',\n        UnknownLabel: 'Undefined label \\'%0\\'',\n        Redeclaration: '%0 \\'%1\\' has already been declared',\n        IllegalContinue: 'Illegal continue statement',\n        IllegalBreak: 'Illegal break statement',\n        IllegalReturn: 'Illegal return statement',\n        StrictModeWith:  'Strict mode code may not include a with statement',\n        StrictCatchVariable:  'Catch variable may not be eval or arguments in strict mode',\n        StrictVarName:  'Variable name may not be eval or arguments in strict mode',\n        StrictParamName:  'Parameter name eval or arguments is not allowed in strict mode',\n        StrictParamDupe: 'Strict mode function may not have duplicate parameter names',\n        StrictFunctionName:  'Function name may not be eval or arguments in strict mode',\n        StrictOctalLiteral:  'Octal literals are not allowed in strict mode.',\n        StrictDelete:  'Delete of an unqualified identifier in strict mode.',\n        StrictDuplicateProperty:  'Duplicate data property in object literal not allowed in strict mode',\n        AccessorDataProperty:  'Object literal may not have data and accessor property with the same name',\n        AccessorGetSet:  'Object literal may not have multiple get/set accessors with the same name',\n        StrictLHSAssignment:  'Assignment to eval or arguments is not allowed in strict mode',\n        StrictLHSPostfix:  'Postfix increment/decrement may not have eval or arguments operand in strict mode',\n        StrictLHSPrefix:  'Prefix increment/decrement may not have eval or arguments operand in strict mode',\n        StrictReservedWord:  'Use of future reserved word in strict mode'\n    };\n\n    // See also tools/generate-unicode-regex.py.\n    Regex = {\n        NonAsciiIdentifierStart: new RegExp('[\\xaa\\xb5\\xba\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02c1\\u02c6-\\u02d1\\u02e0-\\u02e4\\u02ec\\u02ee\\u0370-\\u0374\\u0376\\u0377\\u037a-\\u037d\\u0386\\u0388-\\u038a\\u038c\\u038e-\\u03a1\\u03a3-\\u03f5\\u03f7-\\u0481\\u048a-\\u0527\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05d0-\\u05ea\\u05f0-\\u05f2\\u0620-\\u064a\\u066e\\u066f\\u0671-\\u06d3\\u06d5\\u06e5\\u06e6\\u06ee\\u06ef\\u06fa-\\u06fc\\u06ff\\u0710\\u0712-\\u072f\\u074d-\\u07a5\\u07b1\\u07ca-\\u07ea\\u07f4\\u07f5\\u07fa\\u0800-\\u0815\\u081a\\u0824\\u0828\\u0840-\\u0858\\u08a0\\u08a2-\\u08ac\\u0904-\\u0939\\u093d\\u0950\\u0958-\\u0961\\u0971-\\u0977\\u0979-\\u097f\\u0985-\\u098c\\u098f\\u0990\\u0993-\\u09a8\\u09aa-\\u09b0\\u09b2\\u09b6-\\u09b9\\u09bd\\u09ce\\u09dc\\u09dd\\u09df-\\u09e1\\u09f0\\u09f1\\u0a05-\\u0a0a\\u0a0f\\u0a10\\u0a13-\\u0a28\\u0a2a-\\u0a30\\u0a32\\u0a33\\u0a35\\u0a36\\u0a38\\u0a39\\u0a59-\\u0a5c\\u0a5e\\u0a72-\\u0a74\\u0a85-\\u0a8d\\u0a8f-\\u0a91\\u0a93-\\u0aa8\\u0aaa-\\u0ab0\\u0ab2\\u0ab3\\u0ab5-\\u0ab9\\u0abd\\u0ad0\\u0ae0\\u0ae1\\u0b05-\\u0b0c\\u0b0f\\u0b10\\u0b13-\\u0b28\\u0b2a-\\u0b30\\u0b32\\u0b33\\u0b35-\\u0b39\\u0b3d\\u0b5c\\u0b5d\\u0b5f-\\u0b61\\u0b71\\u0b83\\u0b85-\\u0b8a\\u0b8e-\\u0b90\\u0b92-\\u0b95\\u0b99\\u0b9a\\u0b9c\\u0b9e\\u0b9f\\u0ba3\\u0ba4\\u0ba8-\\u0baa\\u0bae-\\u0bb9\\u0bd0\\u0c05-\\u0c0c\\u0c0e-\\u0c10\\u0c12-\\u0c28\\u0c2a-\\u0c33\\u0c35-\\u0c39\\u0c3d\\u0c58\\u0c59\\u0c60\\u0c61\\u0c85-\\u0c8c\\u0c8e-\\u0c90\\u0c92-\\u0ca8\\u0caa-\\u0cb3\\u0cb5-\\u0cb9\\u0cbd\\u0cde\\u0ce0\\u0ce1\\u0cf1\\u0cf2\\u0d05-\\u0d0c\\u0d0e-\\u0d10\\u0d12-\\u0d3a\\u0d3d\\u0d4e\\u0d60\\u0d61\\u0d7a-\\u0d7f\\u0d85-\\u0d96\\u0d9a-\\u0db1\\u0db3-\\u0dbb\\u0dbd\\u0dc0-\\u0dc6\\u0e01-\\u0e30\\u0e32\\u0e33\\u0e40-\\u0e46\\u0e81\\u0e82\\u0e84\\u0e87\\u0e88\\u0e8a\\u0e8d\\u0e94-\\u0e97\\u0e99-\\u0e9f\\u0ea1-\\u0ea3\\u0ea5\\u0ea7\\u0eaa\\u0eab\\u0ead-\\u0eb0\\u0eb2\\u0eb3\\u0ebd\\u0ec0-\\u0ec4\\u0ec6\\u0edc-\\u0edf\\u0f00\\u0f40-\\u0f47\\u0f49-\\u0f6c\\u0f88-\\u0f8c\\u1000-\\u102a\\u103f\\u1050-\\u1055\\u105a-\\u105d\\u1061\\u1065\\u1066\\u106e-\\u1070\\u1075-\\u1081\\u108e\\u10a0-\\u10c5\\u10c7\\u10cd\\u10d0-\\u10fa\\u10fc-\\u1248\\u124a-\\u124d\\u1250-\\u1256\\u1258\\u125a-\\u125d\\u1260-\\u1288\\u128a-\\u128d\\u1290-\\u12b0\\u12b2-\\u12b5\\u12b8-\\u12be\\u12c0\\u12c2-\\u12c5\\u12c8-\\u12d6\\u12d8-\\u1310\\u1312-\\u1315\\u1318-\\u135a\\u1380-\\u138f\\u13a0-\\u13f4\\u1401-\\u166c\\u166f-\\u167f\\u1681-\\u169a\\u16a0-\\u16ea\\u16ee-\\u16f0\\u1700-\\u170c\\u170e-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176c\\u176e-\\u1770\\u1780-\\u17b3\\u17d7\\u17dc\\u1820-\\u1877\\u1880-\\u18a8\\u18aa\\u18b0-\\u18f5\\u1900-\\u191c\\u1950-\\u196d\\u1970-\\u1974\\u1980-\\u19ab\\u19c1-\\u19c7\\u1a00-\\u1a16\\u1a20-\\u1a54\\u1aa7\\u1b05-\\u1b33\\u1b45-\\u1b4b\\u1b83-\\u1ba0\\u1bae\\u1baf\\u1bba-\\u1be5\\u1c00-\\u1c23\\u1c4d-\\u1c4f\\u1c5a-\\u1c7d\\u1ce9-\\u1cec\\u1cee-\\u1cf1\\u1cf5\\u1cf6\\u1d00-\\u1dbf\\u1e00-\\u1f15\\u1f18-\\u1f1d\\u1f20-\\u1f45\\u1f48-\\u1f4d\\u1f50-\\u1f57\\u1f59\\u1f5b\\u1f5d\\u1f5f-\\u1f7d\\u1f80-\\u1fb4\\u1fb6-\\u1fbc\\u1fbe\\u1fc2-\\u1fc4\\u1fc6-\\u1fcc\\u1fd0-\\u1fd3\\u1fd6-\\u1fdb\\u1fe0-\\u1fec\\u1ff2-\\u1ff4\\u1ff6-\\u1ffc\\u2071\\u207f\\u2090-\\u209c\\u2102\\u2107\\u210a-\\u2113\\u2115\\u2119-\\u211d\\u2124\\u2126\\u2128\\u212a-\\u212d\\u212f-\\u2139\\u213c-\\u213f\\u2145-\\u2149\\u214e\\u2160-\\u2188\\u2c00-\\u2c2e\\u2c30-\\u2c5e\\u2c60-\\u2ce4\\u2ceb-\\u2cee\\u2cf2\\u2cf3\\u2d00-\\u2d25\\u2d27\\u2d2d\\u2d30-\\u2d67\\u2d6f\\u2d80-\\u2d96\\u2da0-\\u2da6\\u2da8-\\u2dae\\u2db0-\\u2db6\\u2db8-\\u2dbe\\u2dc0-\\u2dc6\\u2dc8-\\u2dce\\u2dd0-\\u2dd6\\u2dd8-\\u2dde\\u2e2f\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303c\\u3041-\\u3096\\u309d-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312d\\u3131-\\u318e\\u31a0-\\u31ba\\u31f0-\\u31ff\\u3400-\\u4db5\\u4e00-\\u9fcc\\ua000-\\ua48c\\ua4d0-\\ua4fd\\ua500-\\ua60c\\ua610-\\ua61f\\ua62a\\ua62b\\ua640-\\ua66e\\ua67f-\\ua697\\ua6a0-\\ua6ef\\ua717-\\ua71f\\ua722-\\ua788\\ua78b-\\ua78e\\ua790-\\ua793\\ua7a0-\\ua7aa\\ua7f8-\\ua801\\ua803-\\ua805\\ua807-\\ua80a\\ua80c-\\ua822\\ua840-\\ua873\\ua882-\\ua8b3\\ua8f2-\\ua8f7\\ua8fb\\ua90a-\\ua925\\ua930-\\ua946\\ua960-\\ua97c\\ua984-\\ua9b2\\ua9cf\\uaa00-\\uaa28\\uaa40-\\uaa42\\uaa44-\\uaa4b\\uaa60-\\uaa76\\uaa7a\\uaa80-\\uaaaf\\uaab1\\uaab5\\uaab6\\uaab9-\\uaabd\\uaac0\\uaac2\\uaadb-\\uaadd\\uaae0-\\uaaea\\uaaf2-\\uaaf4\\uab01-\\uab06\\uab09-\\uab0e\\uab11-\\uab16\\uab20-\\uab26\\uab28-\\uab2e\\uabc0-\\uabe2\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufb00-\\ufb06\\ufb13-\\ufb17\\ufb1d\\ufb1f-\\ufb28\\ufb2a-\\ufb36\\ufb38-\\ufb3c\\ufb3e\\ufb40\\ufb41\\ufb43\\ufb44\\ufb46-\\ufbb1\\ufbd3-\\ufd3d\\ufd50-\\ufd8f\\ufd92-\\ufdc7\\ufdf0-\\ufdfb\\ufe70-\\ufe74\\ufe76-\\ufefc\\uff21-\\uff3a\\uff41-\\uff5a\\uff66-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc]'),\n        NonAsciiIdentifierPart: new RegExp('[\\xaa\\xb5\\xba\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02c1\\u02c6-\\u02d1\\u02e0-\\u02e4\\u02ec\\u02ee\\u0300-\\u0374\\u0376\\u0377\\u037a-\\u037d\\u0386\\u0388-\\u038a\\u038c\\u038e-\\u03a1\\u03a3-\\u03f5\\u03f7-\\u0481\\u0483-\\u0487\\u048a-\\u0527\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u0591-\\u05bd\\u05bf\\u05c1\\u05c2\\u05c4\\u05c5\\u05c7\\u05d0-\\u05ea\\u05f0-\\u05f2\\u0610-\\u061a\\u0620-\\u0669\\u066e-\\u06d3\\u06d5-\\u06dc\\u06df-\\u06e8\\u06ea-\\u06fc\\u06ff\\u0710-\\u074a\\u074d-\\u07b1\\u07c0-\\u07f5\\u07fa\\u0800-\\u082d\\u0840-\\u085b\\u08a0\\u08a2-\\u08ac\\u08e4-\\u08fe\\u0900-\\u0963\\u0966-\\u096f\\u0971-\\u0977\\u0979-\\u097f\\u0981-\\u0983\\u0985-\\u098c\\u098f\\u0990\\u0993-\\u09a8\\u09aa-\\u09b0\\u09b2\\u09b6-\\u09b9\\u09bc-\\u09c4\\u09c7\\u09c8\\u09cb-\\u09ce\\u09d7\\u09dc\\u09dd\\u09df-\\u09e3\\u09e6-\\u09f1\\u0a01-\\u0a03\\u0a05-\\u0a0a\\u0a0f\\u0a10\\u0a13-\\u0a28\\u0a2a-\\u0a30\\u0a32\\u0a33\\u0a35\\u0a36\\u0a38\\u0a39\\u0a3c\\u0a3e-\\u0a42\\u0a47\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a59-\\u0a5c\\u0a5e\\u0a66-\\u0a75\\u0a81-\\u0a83\\u0a85-\\u0a8d\\u0a8f-\\u0a91\\u0a93-\\u0aa8\\u0aaa-\\u0ab0\\u0ab2\\u0ab3\\u0ab5-\\u0ab9\\u0abc-\\u0ac5\\u0ac7-\\u0ac9\\u0acb-\\u0acd\\u0ad0\\u0ae0-\\u0ae3\\u0ae6-\\u0aef\\u0b01-\\u0b03\\u0b05-\\u0b0c\\u0b0f\\u0b10\\u0b13-\\u0b28\\u0b2a-\\u0b30\\u0b32\\u0b33\\u0b35-\\u0b39\\u0b3c-\\u0b44\\u0b47\\u0b48\\u0b4b-\\u0b4d\\u0b56\\u0b57\\u0b5c\\u0b5d\\u0b5f-\\u0b63\\u0b66-\\u0b6f\\u0b71\\u0b82\\u0b83\\u0b85-\\u0b8a\\u0b8e-\\u0b90\\u0b92-\\u0b95\\u0b99\\u0b9a\\u0b9c\\u0b9e\\u0b9f\\u0ba3\\u0ba4\\u0ba8-\\u0baa\\u0bae-\\u0bb9\\u0bbe-\\u0bc2\\u0bc6-\\u0bc8\\u0bca-\\u0bcd\\u0bd0\\u0bd7\\u0be6-\\u0bef\\u0c01-\\u0c03\\u0c05-\\u0c0c\\u0c0e-\\u0c10\\u0c12-\\u0c28\\u0c2a-\\u0c33\\u0c35-\\u0c39\\u0c3d-\\u0c44\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55\\u0c56\\u0c58\\u0c59\\u0c60-\\u0c63\\u0c66-\\u0c6f\\u0c82\\u0c83\\u0c85-\\u0c8c\\u0c8e-\\u0c90\\u0c92-\\u0ca8\\u0caa-\\u0cb3\\u0cb5-\\u0cb9\\u0cbc-\\u0cc4\\u0cc6-\\u0cc8\\u0cca-\\u0ccd\\u0cd5\\u0cd6\\u0cde\\u0ce0-\\u0ce3\\u0ce6-\\u0cef\\u0cf1\\u0cf2\\u0d02\\u0d03\\u0d05-\\u0d0c\\u0d0e-\\u0d10\\u0d12-\\u0d3a\\u0d3d-\\u0d44\\u0d46-\\u0d48\\u0d4a-\\u0d4e\\u0d57\\u0d60-\\u0d63\\u0d66-\\u0d6f\\u0d7a-\\u0d7f\\u0d82\\u0d83\\u0d85-\\u0d96\\u0d9a-\\u0db1\\u0db3-\\u0dbb\\u0dbd\\u0dc0-\\u0dc6\\u0dca\\u0dcf-\\u0dd4\\u0dd6\\u0dd8-\\u0ddf\\u0df2\\u0df3\\u0e01-\\u0e3a\\u0e40-\\u0e4e\\u0e50-\\u0e59\\u0e81\\u0e82\\u0e84\\u0e87\\u0e88\\u0e8a\\u0e8d\\u0e94-\\u0e97\\u0e99-\\u0e9f\\u0ea1-\\u0ea3\\u0ea5\\u0ea7\\u0eaa\\u0eab\\u0ead-\\u0eb9\\u0ebb-\\u0ebd\\u0ec0-\\u0ec4\\u0ec6\\u0ec8-\\u0ecd\\u0ed0-\\u0ed9\\u0edc-\\u0edf\\u0f00\\u0f18\\u0f19\\u0f20-\\u0f29\\u0f35\\u0f37\\u0f39\\u0f3e-\\u0f47\\u0f49-\\u0f6c\\u0f71-\\u0f84\\u0f86-\\u0f97\\u0f99-\\u0fbc\\u0fc6\\u1000-\\u1049\\u1050-\\u109d\\u10a0-\\u10c5\\u10c7\\u10cd\\u10d0-\\u10fa\\u10fc-\\u1248\\u124a-\\u124d\\u1250-\\u1256\\u1258\\u125a-\\u125d\\u1260-\\u1288\\u128a-\\u128d\\u1290-\\u12b0\\u12b2-\\u12b5\\u12b8-\\u12be\\u12c0\\u12c2-\\u12c5\\u12c8-\\u12d6\\u12d8-\\u1310\\u1312-\\u1315\\u1318-\\u135a\\u135d-\\u135f\\u1380-\\u138f\\u13a0-\\u13f4\\u1401-\\u166c\\u166f-\\u167f\\u1681-\\u169a\\u16a0-\\u16ea\\u16ee-\\u16f0\\u1700-\\u170c\\u170e-\\u1714\\u1720-\\u1734\\u1740-\\u1753\\u1760-\\u176c\\u176e-\\u1770\\u1772\\u1773\\u1780-\\u17d3\\u17d7\\u17dc\\u17dd\\u17e0-\\u17e9\\u180b-\\u180d\\u1810-\\u1819\\u1820-\\u1877\\u1880-\\u18aa\\u18b0-\\u18f5\\u1900-\\u191c\\u1920-\\u192b\\u1930-\\u193b\\u1946-\\u196d\\u1970-\\u1974\\u1980-\\u19ab\\u19b0-\\u19c9\\u19d0-\\u19d9\\u1a00-\\u1a1b\\u1a20-\\u1a5e\\u1a60-\\u1a7c\\u1a7f-\\u1a89\\u1a90-\\u1a99\\u1aa7\\u1b00-\\u1b4b\\u1b50-\\u1b59\\u1b6b-\\u1b73\\u1b80-\\u1bf3\\u1c00-\\u1c37\\u1c40-\\u1c49\\u1c4d-\\u1c7d\\u1cd0-\\u1cd2\\u1cd4-\\u1cf6\\u1d00-\\u1de6\\u1dfc-\\u1f15\\u1f18-\\u1f1d\\u1f20-\\u1f45\\u1f48-\\u1f4d\\u1f50-\\u1f57\\u1f59\\u1f5b\\u1f5d\\u1f5f-\\u1f7d\\u1f80-\\u1fb4\\u1fb6-\\u1fbc\\u1fbe\\u1fc2-\\u1fc4\\u1fc6-\\u1fcc\\u1fd0-\\u1fd3\\u1fd6-\\u1fdb\\u1fe0-\\u1fec\\u1ff2-\\u1ff4\\u1ff6-\\u1ffc\\u200c\\u200d\\u203f\\u2040\\u2054\\u2071\\u207f\\u2090-\\u209c\\u20d0-\\u20dc\\u20e1\\u20e5-\\u20f0\\u2102\\u2107\\u210a-\\u2113\\u2115\\u2119-\\u211d\\u2124\\u2126\\u2128\\u212a-\\u212d\\u212f-\\u2139\\u213c-\\u213f\\u2145-\\u2149\\u214e\\u2160-\\u2188\\u2c00-\\u2c2e\\u2c30-\\u2c5e\\u2c60-\\u2ce4\\u2ceb-\\u2cf3\\u2d00-\\u2d25\\u2d27\\u2d2d\\u2d30-\\u2d67\\u2d6f\\u2d7f-\\u2d96\\u2da0-\\u2da6\\u2da8-\\u2dae\\u2db0-\\u2db6\\u2db8-\\u2dbe\\u2dc0-\\u2dc6\\u2dc8-\\u2dce\\u2dd0-\\u2dd6\\u2dd8-\\u2dde\\u2de0-\\u2dff\\u2e2f\\u3005-\\u3007\\u3021-\\u302f\\u3031-\\u3035\\u3038-\\u303c\\u3041-\\u3096\\u3099\\u309a\\u309d-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312d\\u3131-\\u318e\\u31a0-\\u31ba\\u31f0-\\u31ff\\u3400-\\u4db5\\u4e00-\\u9fcc\\ua000-\\ua48c\\ua4d0-\\ua4fd\\ua500-\\ua60c\\ua610-\\ua62b\\ua640-\\ua66f\\ua674-\\ua67d\\ua67f-\\ua697\\ua69f-\\ua6f1\\ua717-\\ua71f\\ua722-\\ua788\\ua78b-\\ua78e\\ua790-\\ua793\\ua7a0-\\ua7aa\\ua7f8-\\ua827\\ua840-\\ua873\\ua880-\\ua8c4\\ua8d0-\\ua8d9\\ua8e0-\\ua8f7\\ua8fb\\ua900-\\ua92d\\ua930-\\ua953\\ua960-\\ua97c\\ua980-\\ua9c0\\ua9cf-\\ua9d9\\uaa00-\\uaa36\\uaa40-\\uaa4d\\uaa50-\\uaa59\\uaa60-\\uaa76\\uaa7a\\uaa7b\\uaa80-\\uaac2\\uaadb-\\uaadd\\uaae0-\\uaaef\\uaaf2-\\uaaf6\\uab01-\\uab06\\uab09-\\uab0e\\uab11-\\uab16\\uab20-\\uab26\\uab28-\\uab2e\\uabc0-\\uabea\\uabec\\uabed\\uabf0-\\uabf9\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufb00-\\ufb06\\ufb13-\\ufb17\\ufb1d-\\ufb28\\ufb2a-\\ufb36\\ufb38-\\ufb3c\\ufb3e\\ufb40\\ufb41\\ufb43\\ufb44\\ufb46-\\ufbb1\\ufbd3-\\ufd3d\\ufd50-\\ufd8f\\ufd92-\\ufdc7\\ufdf0-\\ufdfb\\ufe00-\\ufe0f\\ufe20-\\ufe26\\ufe33\\ufe34\\ufe4d-\\ufe4f\\ufe70-\\ufe74\\ufe76-\\ufefc\\uff10-\\uff19\\uff21-\\uff3a\\uff3f\\uff41-\\uff5a\\uff66-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc]')\n    };\n\n    // Ensure the condition is true, otherwise throw an error.\n    // This is only to have a better contract semantic, i.e. another safety net\n    // to catch a logic error. The condition shall be fulfilled in normal case.\n    // Do NOT use this to enforce a certain condition on any user input.\n\n    function assert(condition, message) {\n        if (!condition) {\n            throw new Error('ASSERT: ' + message);\n        }\n    }\n\n    function isDecimalDigit(ch) {\n        return (ch >= 48 && ch <= 57);   // 0..9\n    }\n\n    function isHexDigit(ch) {\n        return '0123456789abcdefABCDEF'.indexOf(ch) >= 0;\n    }\n\n    function isOctalDigit(ch) {\n        return '01234567'.indexOf(ch) >= 0;\n    }\n\n\n    // 7.2 White Space\n\n    function isWhiteSpace(ch) {\n        return (ch === 32) ||  // space\n            (ch === 9) ||      // tab\n            (ch === 0xB) ||\n            (ch === 0xC) ||\n            (ch === 0xA0) ||\n            (ch >= 0x1680 && '\\u1680\\u180E\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u202F\\u205F\\u3000\\uFEFF'.indexOf(String.fromCharCode(ch)) > 0);\n    }\n\n    // 7.3 Line Terminators\n\n    function isLineTerminator(ch) {\n        return (ch === 10) || (ch === 13) || (ch === 0x2028) || (ch === 0x2029);\n    }\n\n    // 7.6 Identifier Names and Identifiers\n\n    function isIdentifierStart(ch) {\n        return (ch === 36) || (ch === 95) ||  // $ (dollar) and _ (underscore)\n            (ch >= 65 && ch <= 90) ||         // A..Z\n            (ch >= 97 && ch <= 122) ||        // a..z\n            (ch === 92) ||                    // \\ (backslash)\n            ((ch >= 0x80) && Regex.NonAsciiIdentifierStart.test(String.fromCharCode(ch)));\n    }\n\n    function isIdentifierPart(ch) {\n        return (ch === 36) || (ch === 95) ||  // $ (dollar) and _ (underscore)\n            (ch >= 65 && ch <= 90) ||         // A..Z\n            (ch >= 97 && ch <= 122) ||        // a..z\n            (ch >= 48 && ch <= 57) ||         // 0..9\n            (ch === 92) ||                    // \\ (backslash)\n            ((ch >= 0x80) && Regex.NonAsciiIdentifierPart.test(String.fromCharCode(ch)));\n    }\n\n    // 7.6.1.2 Future Reserved Words\n\n    function isFutureReservedWord(id) {\n        switch (id) {\n        case 'class':\n        case 'enum':\n        case 'export':\n        case 'extends':\n        case 'import':\n        case 'super':\n            return true;\n        default:\n            return false;\n        }\n    }\n\n    function isStrictModeReservedWord(id) {\n        switch (id) {\n        case 'implements':\n        case 'interface':\n        case 'package':\n        case 'private':\n        case 'protected':\n        case 'public':\n        case 'static':\n        case 'yield':\n        case 'let':\n            return true;\n        default:\n            return false;\n        }\n    }\n\n    function isRestrictedWord(id) {\n        return id === 'eval' || id === 'arguments';\n    }\n\n    // 7.6.1.1 Keywords\n\n    function isKeyword(id) {\n        if (strict && isStrictModeReservedWord(id)) {\n            return true;\n        }\n\n        // 'const' is specialized as Keyword in V8.\n        // 'yield' and 'let' are for compatiblity with SpiderMonkey and ES.next.\n        // Some others are from future reserved words.\n\n        switch (id.length) {\n        case 2:\n            return (id === 'if') || (id === 'in') || (id === 'do');\n        case 3:\n            return (id === 'var') || (id === 'for') || (id === 'new') ||\n                (id === 'try') || (id === 'let');\n        case 4:\n            return (id === 'this') || (id === 'else') || (id === 'case') ||\n                (id === 'void') || (id === 'with') || (id === 'enum');\n        case 5:\n            return (id === 'while') || (id === 'break') || (id === 'catch') ||\n                (id === 'throw') || (id === 'const') || (id === 'yield') ||\n                (id === 'class') || (id === 'super');\n        case 6:\n            return (id === 'return') || (id === 'typeof') || (id === 'delete') ||\n                (id === 'switch') || (id === 'export') || (id === 'import');\n        case 7:\n            return (id === 'default') || (id === 'finally') || (id === 'extends');\n        case 8:\n            return (id === 'function') || (id === 'continue') || (id === 'debugger');\n        case 10:\n            return (id === 'instanceof');\n        default:\n            return false;\n        }\n    }\n\n    // 7.4 Comments\n\n    function addComment(type, value, start, end, loc) {\n        var comment;\n\n        assert(typeof start === 'number', 'Comment must have valid position');\n\n        // Because the way the actual token is scanned, often the comments\n        // (if any) are skipped twice during the lexical analysis.\n        // Thus, we need to skip adding a comment if the comment array already\n        // handled it.\n        if (state.lastCommentStart >= start) {\n            return;\n        }\n        state.lastCommentStart = start;\n\n        comment = {\n            type: type,\n            value: value\n        };\n        if (extra.range) {\n            comment.range = [start, end];\n        }\n        if (extra.loc) {\n            comment.loc = loc;\n        }\n        extra.comments.push(comment);\n    }\n\n    function skipSingleLineComment() {\n        var start, loc, ch, comment;\n\n        start = index - 2;\n        loc = {\n            start: {\n                line: lineNumber,\n                column: index - lineStart - 2\n            }\n        };\n\n        while (index < length) {\n            ch = source.charCodeAt(index);\n            ++index;\n            if (isLineTerminator(ch)) {\n                if (extra.comments) {\n                    comment = source.slice(start + 2, index - 1);\n                    loc.end = {\n                        line: lineNumber,\n                        column: index - lineStart - 1\n                    };\n                    addComment('Line', comment, start, index - 1, loc);\n                }\n                if (ch === 13 && source.charCodeAt(index) === 10) {\n                    ++index;\n                }\n                ++lineNumber;\n                lineStart = index;\n                return;\n            }\n        }\n\n        if (extra.comments) {\n            comment = source.slice(start + 2, index);\n            loc.end = {\n                line: lineNumber,\n                column: index - lineStart\n            };\n            addComment('Line', comment, start, index, loc);\n        }\n    }\n\n    function skipMultiLineComment() {\n        var start, loc, ch, comment;\n\n        if (extra.comments) {\n            start = index - 2;\n            loc = {\n                start: {\n                    line: lineNumber,\n                    column: index - lineStart - 2\n                }\n            };\n        }\n\n        while (index < length) {\n            ch = source.charCodeAt(index);\n            if (isLineTerminator(ch)) {\n                if (ch === 13 && source.charCodeAt(index + 1) === 10) {\n                    ++index;\n                }\n                ++lineNumber;\n                ++index;\n                lineStart = index;\n                if (index >= length) {\n                    throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n                }\n            } else if (ch === 42) {\n                // Block comment ends with '*/' (char #42, char #47).\n                if (source.charCodeAt(index + 1) === 47) {\n                    ++index;\n                    ++index;\n                    if (extra.comments) {\n                        comment = source.slice(start + 2, index - 2);\n                        loc.end = {\n                            line: lineNumber,\n                            column: index - lineStart\n                        };\n                        addComment('Block', comment, start, index, loc);\n                    }\n                    return;\n                }\n                ++index;\n            } else {\n                ++index;\n            }\n        }\n\n        throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n    }\n\n    function skipComment() {\n        var ch;\n\n        while (index < length) {\n            ch = source.charCodeAt(index);\n\n            if (isWhiteSpace(ch)) {\n                ++index;\n            } else if (isLineTerminator(ch)) {\n                ++index;\n                if (ch === 13 && source.charCodeAt(index) === 10) {\n                    ++index;\n                }\n                ++lineNumber;\n                lineStart = index;\n            } else if (ch === 47) { // 47 is '/'\n                ch = source.charCodeAt(index + 1);\n                if (ch === 47) {\n                    ++index;\n                    ++index;\n                    skipSingleLineComment();\n                } else if (ch === 42) {  // 42 is '*'\n                    ++index;\n                    ++index;\n                    skipMultiLineComment();\n                } else {\n                    break;\n                }\n            } else {\n                break;\n            }\n        }\n    }\n\n    function scanHexEscape(prefix) {\n        var i, len, ch, code = 0;\n\n        len = (prefix === 'u') ? 4 : 2;\n        for (i = 0; i < len; ++i) {\n            if (index < length && isHexDigit(source[index])) {\n                ch = source[index++];\n                code = code * 16 + '0123456789abcdef'.indexOf(ch.toLowerCase());\n            } else {\n                return '';\n            }\n        }\n        return String.fromCharCode(code);\n    }\n\n    function getEscapedIdentifier() {\n        var ch, id;\n\n        ch = source.charCodeAt(index++);\n        id = String.fromCharCode(ch);\n\n        // '\\u' (char #92, char #117) denotes an escaped character.\n        if (ch === 92) {\n            if (source.charCodeAt(index) !== 117) {\n                throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n            }\n            ++index;\n            ch = scanHexEscape('u');\n            if (!ch || ch === '\\\\' || !isIdentifierStart(ch.charCodeAt(0))) {\n                throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n            }\n            id = ch;\n        }\n\n        while (index < length) {\n            ch = source.charCodeAt(index);\n            if (!isIdentifierPart(ch)) {\n                break;\n            }\n            ++index;\n            id += String.fromCharCode(ch);\n\n            // '\\u' (char #92, char #117) denotes an escaped character.\n            if (ch === 92) {\n                id = id.substr(0, id.length - 1);\n                if (source.charCodeAt(index) !== 117) {\n                    throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n                }\n                ++index;\n                ch = scanHexEscape('u');\n                if (!ch || ch === '\\\\' || !isIdentifierPart(ch.charCodeAt(0))) {\n                    throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n                }\n                id += ch;\n            }\n        }\n\n        return id;\n    }\n\n    function getIdentifier() {\n        var start, ch;\n\n        start = index++;\n        while (index < length) {\n            ch = source.charCodeAt(index);\n            if (ch === 92) {\n                // Blackslash (char #92) marks Unicode escape sequence.\n                index = start;\n                return getEscapedIdentifier();\n            }\n            if (isIdentifierPart(ch)) {\n                ++index;\n            } else {\n                break;\n            }\n        }\n\n        return source.slice(start, index);\n    }\n\n    function scanIdentifier() {\n        var start, id, type;\n\n        start = index;\n\n        // Backslash (char #92) starts an escaped character.\n        id = (source.charCodeAt(index) === 92) ? getEscapedIdentifier() : getIdentifier();\n\n        // There is no keyword or literal with only one character.\n        // Thus, it must be an identifier.\n        if (id.length === 1) {\n            type = Token.Identifier;\n        } else if (isKeyword(id)) {\n            type = Token.Keyword;\n        } else if (id === 'null') {\n            type = Token.NullLiteral;\n        } else if (id === 'true' || id === 'false') {\n            type = Token.BooleanLiteral;\n        } else {\n            type = Token.Identifier;\n        }\n\n        return {\n            type: type,\n            value: id,\n            lineNumber: lineNumber,\n            lineStart: lineStart,\n            range: [start, index]\n        };\n    }\n\n\n    // 7.7 Punctuators\n\n    function scanPunctuator() {\n        var start = index,\n            code = source.charCodeAt(index),\n            code2,\n            ch1 = source[index],\n            ch2,\n            ch3,\n            ch4;\n\n        switch (code) {\n\n        // Check for most common single-character punctuators.\n        case 46:   // . dot\n        case 40:   // ( open bracket\n        case 41:   // ) close bracket\n        case 59:   // ; semicolon\n        case 44:   // , comma\n        case 123:  // { open curly brace\n        case 125:  // } close curly brace\n        case 91:   // [\n        case 93:   // ]\n        case 58:   // :\n        case 63:   // ?\n        case 126:  // ~\n            ++index;\n            if (extra.tokenize) {\n                if (code === 40) {\n                    extra.openParenToken = extra.tokens.length;\n                } else if (code === 123) {\n                    extra.openCurlyToken = extra.tokens.length;\n                }\n            }\n            return {\n                type: Token.Punctuator,\n                value: String.fromCharCode(code),\n                lineNumber: lineNumber,\n                lineStart: lineStart,\n                range: [start, index]\n            };\n\n        default:\n            code2 = source.charCodeAt(index + 1);\n\n            // '=' (char #61) marks an assignment or comparison operator.\n            if (code2 === 61) {\n                switch (code) {\n                case 37:  // %\n                case 38:  // &\n                case 42:  // *:\n                case 43:  // +\n                case 45:  // -\n                case 47:  // /\n                case 60:  // <\n                case 62:  // >\n                case 94:  // ^\n                case 124: // |\n                    index += 2;\n                    return {\n                        type: Token.Punctuator,\n                        value: String.fromCharCode(code) + String.fromCharCode(code2),\n                        lineNumber: lineNumber,\n                        lineStart: lineStart,\n                        range: [start, index]\n                    };\n\n                case 33: // !\n                case 61: // =\n                    index += 2;\n\n                    // !== and ===\n                    if (source.charCodeAt(index) === 61) {\n                        ++index;\n                    }\n                    return {\n                        type: Token.Punctuator,\n                        value: source.slice(start, index),\n                        lineNumber: lineNumber,\n                        lineStart: lineStart,\n                        range: [start, index]\n                    };\n                default:\n                    break;\n                }\n            }\n            break;\n        }\n\n        // Peek more characters.\n\n        ch2 = source[index + 1];\n        ch3 = source[index + 2];\n        ch4 = source[index + 3];\n\n        // 4-character punctuator: >>>=\n\n        if (ch1 === '>' && ch2 === '>' && ch3 === '>') {\n            if (ch4 === '=') {\n                index += 4;\n                return {\n                    type: Token.Punctuator,\n                    value: '>>>=',\n                    lineNumber: lineNumber,\n                    lineStart: lineStart,\n                    range: [start, index]\n                };\n            }\n        }\n\n        // 3-character punctuators: === !== >>> <<= >>=\n\n        if (ch1 === '>' && ch2 === '>' && ch3 === '>') {\n            index += 3;\n            return {\n                type: Token.Punctuator,\n                value: '>>>',\n                lineNumber: lineNumber,\n                lineStart: lineStart,\n                range: [start, index]\n            };\n        }\n\n        if (ch1 === '<' && ch2 === '<' && ch3 === '=') {\n            index += 3;\n            return {\n                type: Token.Punctuator,\n                value: '<<=',\n                lineNumber: lineNumber,\n                lineStart: lineStart,\n                range: [start, index]\n            };\n        }\n\n        if (ch1 === '>' && ch2 === '>' && ch3 === '=') {\n            index += 3;\n            return {\n                type: Token.Punctuator,\n                value: '>>=',\n                lineNumber: lineNumber,\n                lineStart: lineStart,\n                range: [start, index]\n            };\n        }\n\n        // Other 2-character punctuators: ++ -- << >> && ||\n\n        if (ch1 === ch2 && ('+-<>&|'.indexOf(ch1) >= 0)) {\n            index += 2;\n            return {\n                type: Token.Punctuator,\n                value: ch1 + ch2,\n                lineNumber: lineNumber,\n                lineStart: lineStart,\n                range: [start, index]\n            };\n        }\n\n        if ('<>=!+-*%&|^/'.indexOf(ch1) >= 0) {\n            ++index;\n            return {\n                type: Token.Punctuator,\n                value: ch1,\n                lineNumber: lineNumber,\n                lineStart: lineStart,\n                range: [start, index]\n            };\n        }\n\n        throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n    }\n\n    // 7.8.3 Numeric Literals\n\n    function scanHexLiteral(start) {\n        var number = '';\n\n        while (index < length) {\n            if (!isHexDigit(source[index])) {\n                break;\n            }\n            number += source[index++];\n        }\n\n        if (number.length === 0) {\n            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n        }\n\n        if (isIdentifierStart(source.charCodeAt(index))) {\n            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n        }\n\n        return {\n            type: Token.NumericLiteral,\n            value: parseInt('0x' + number, 16),\n            lineNumber: lineNumber,\n            lineStart: lineStart,\n            range: [start, index]\n        };\n    }\n\n    function scanOctalLiteral(start) {\n        var number = '0' + source[index++];\n        while (index < length) {\n            if (!isOctalDigit(source[index])) {\n                break;\n            }\n            number += source[index++];\n        }\n\n        if (isIdentifierStart(source.charCodeAt(index)) || isDecimalDigit(source.charCodeAt(index))) {\n            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n        }\n\n        return {\n            type: Token.NumericLiteral,\n            value: parseInt(number, 8),\n            octal: true,\n            lineNumber: lineNumber,\n            lineStart: lineStart,\n            range: [start, index]\n        };\n    }\n\n    function scanNumericLiteral() {\n        var number, start, ch;\n\n        ch = source[index];\n        assert(isDecimalDigit(ch.charCodeAt(0)) || (ch === '.'),\n            'Numeric literal must start with a decimal digit or a decimal point');\n\n        start = index;\n        number = '';\n        if (ch !== '.') {\n            number = source[index++];\n            ch = source[index];\n\n            // Hex number starts with '0x'.\n            // Octal number starts with '0'.\n            if (number === '0') {\n                if (ch === 'x' || ch === 'X') {\n                    ++index;\n                    return scanHexLiteral(start);\n                }\n                if (isOctalDigit(ch)) {\n                    return scanOctalLiteral(start);\n                }\n\n                // decimal number starts with '0' such as '09' is illegal.\n                if (ch && isDecimalDigit(ch.charCodeAt(0))) {\n                    throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n                }\n            }\n\n            while (isDecimalDigit(source.charCodeAt(index))) {\n                number += source[index++];\n            }\n            ch = source[index];\n        }\n\n        if (ch === '.') {\n            number += source[index++];\n            while (isDecimalDigit(source.charCodeAt(index))) {\n                number += source[index++];\n            }\n            ch = source[index];\n        }\n\n        if (ch === 'e' || ch === 'E') {\n            number += source[index++];\n\n            ch = source[index];\n            if (ch === '+' || ch === '-') {\n                number += source[index++];\n            }\n            if (isDecimalDigit(source.charCodeAt(index))) {\n                while (isDecimalDigit(source.charCodeAt(index))) {\n                    number += source[index++];\n                }\n            } else {\n                throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n            }\n        }\n\n        if (isIdentifierStart(source.charCodeAt(index))) {\n            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n        }\n\n        return {\n            type: Token.NumericLiteral,\n            value: parseFloat(number),\n            lineNumber: lineNumber,\n            lineStart: lineStart,\n            range: [start, index]\n        };\n    }\n\n    // 7.8.4 String Literals\n\n    function scanStringLiteral() {\n        var str = '', quote, start, ch, code, unescaped, restore, octal = false;\n\n        quote = source[index];\n        assert((quote === '\\'' || quote === '\"'),\n            'String literal must starts with a quote');\n\n        start = index;\n        ++index;\n\n        while (index < length) {\n            ch = source[index++];\n\n            if (ch === quote) {\n                quote = '';\n                break;\n            } else if (ch === '\\\\') {\n                ch = source[index++];\n                if (!ch || !isLineTerminator(ch.charCodeAt(0))) {\n                    switch (ch) {\n                    case 'n':\n                        str += '\\n';\n                        break;\n                    case 'r':\n                        str += '\\r';\n                        break;\n                    case 't':\n                        str += '\\t';\n                        break;\n                    case 'u':\n                    case 'x':\n                        restore = index;\n                        unescaped = scanHexEscape(ch);\n                        if (unescaped) {\n                            str += unescaped;\n                        } else {\n                            index = restore;\n                            str += ch;\n                        }\n                        break;\n                    case 'b':\n                        str += '\\b';\n                        break;\n                    case 'f':\n                        str += '\\f';\n                        break;\n                    case 'v':\n                        str += '\\x0B';\n                        break;\n\n                    default:\n                        if (isOctalDigit(ch)) {\n                            code = '01234567'.indexOf(ch);\n\n                            // \\0 is not octal escape sequence\n                            if (code !== 0) {\n                                octal = true;\n                            }\n\n                            if (index < length && isOctalDigit(source[index])) {\n                                octal = true;\n                                code = code * 8 + '01234567'.indexOf(source[index++]);\n\n                                // 3 digits are only allowed when string starts\n                                // with 0, 1, 2, 3\n                                if ('0123'.indexOf(ch) >= 0 &&\n                                        index < length &&\n                                        isOctalDigit(source[index])) {\n                                    code = code * 8 + '01234567'.indexOf(source[index++]);\n                                }\n                            }\n                            str += String.fromCharCode(code);\n                        } else {\n                            str += ch;\n                        }\n                        break;\n                    }\n                } else {\n                    ++lineNumber;\n                    if (ch ===  '\\r' && source[index] === '\\n') {\n                        ++index;\n                    }\n                }\n            } else if (isLineTerminator(ch.charCodeAt(0))) {\n                break;\n            } else {\n                str += ch;\n            }\n        }\n\n        if (quote !== '') {\n            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n        }\n\n        return {\n            type: Token.StringLiteral,\n            value: str,\n            octal: octal,\n            lineNumber: lineNumber,\n            lineStart: lineStart,\n            range: [start, index]\n        };\n    }\n\n    function scanRegExp() {\n        var str, ch, start, pattern, flags, value, classMarker = false, restore, terminated = false;\n\n        lookahead = null;\n        skipComment();\n\n        start = index;\n        ch = source[index];\n        assert(ch === '/', 'Regular expression literal must start with a slash');\n        str = source[index++];\n\n        while (index < length) {\n            ch = source[index++];\n            str += ch;\n            if (classMarker) {\n                if (ch === ']') {\n                    classMarker = false;\n                }\n            } else {\n                if (ch === '\\\\') {\n                    ch = source[index++];\n                    // ECMA-262 7.8.5\n                    if (isLineTerminator(ch.charCodeAt(0))) {\n                        throwError({}, Messages.UnterminatedRegExp);\n                    }\n                    str += ch;\n                } else if (ch === '/') {\n                    terminated = true;\n                    break;\n                } else if (ch === '[') {\n                    classMarker = true;\n                } else if (isLineTerminator(ch.charCodeAt(0))) {\n                    throwError({}, Messages.UnterminatedRegExp);\n                }\n            }\n        }\n\n        if (!terminated) {\n            throwError({}, Messages.UnterminatedRegExp);\n        }\n\n        // Exclude leading and trailing slash.\n        pattern = str.substr(1, str.length - 2);\n\n        flags = '';\n        while (index < length) {\n            ch = source[index];\n            if (!isIdentifierPart(ch.charCodeAt(0))) {\n                break;\n            }\n\n            ++index;\n            if (ch === '\\\\' && index < length) {\n                ch = source[index];\n                if (ch === 'u') {\n                    ++index;\n                    restore = index;\n                    ch = scanHexEscape('u');\n                    if (ch) {\n                        flags += ch;\n                        for (str += '\\\\u'; restore < index; ++restore) {\n                            str += source[restore];\n                        }\n                    } else {\n                        index = restore;\n                        flags += 'u';\n                        str += '\\\\u';\n                    }\n                } else {\n                    str += '\\\\';\n                }\n            } else {\n                flags += ch;\n                str += ch;\n            }\n        }\n\n        try {\n            value = new RegExp(pattern, flags);\n        } catch (e) {\n            throwError({}, Messages.InvalidRegExp);\n        }\n\n        peek();\n\n\n        if (extra.tokenize) {\n            return {\n                type: Token.RegularExpression,\n                value: value,\n                lineNumber: lineNumber,\n                lineStart: lineStart,\n                range: [start, index]\n            };\n        }\n        return {\n            literal: str,\n            value: value,\n            range: [start, index]\n        };\n    }\n\n    function collectRegex() {\n        var pos, loc, regex, token;\n\n        skipComment();\n\n        pos = index;\n        loc = {\n            start: {\n                line: lineNumber,\n                column: index - lineStart\n            }\n        };\n\n        regex = scanRegExp();\n        loc.end = {\n            line: lineNumber,\n            column: index - lineStart\n        };\n\n        if (!extra.tokenize) {\n            // Pop the previous token, which is likely '/' or '/='\n            if (extra.tokens.length > 0) {\n                token = extra.tokens[extra.tokens.length - 1];\n                if (token.range[0] === pos && token.type === 'Punctuator') {\n                    if (token.value === '/' || token.value === '/=') {\n                        extra.tokens.pop();\n                    }\n                }\n            }\n\n            extra.tokens.push({\n                type: 'RegularExpression',\n                value: regex.literal,\n                range: [pos, index],\n                loc: loc\n            });\n        }\n\n        return regex;\n    }\n\n    function isIdentifierName(token) {\n        return token.type === Token.Identifier ||\n            token.type === Token.Keyword ||\n            token.type === Token.BooleanLiteral ||\n            token.type === Token.NullLiteral;\n    }\n\n    function advanceSlash() {\n        var prevToken,\n            checkToken;\n        // Using the following algorithm:\n        // https://github.com/mozilla/sweet.js/wiki/design\n        prevToken = extra.tokens[extra.tokens.length - 1];\n        if (!prevToken) {\n            // Nothing before that: it cannot be a division.\n            return collectRegex();\n        }\n        if (prevToken.type === 'Punctuator') {\n            if (prevToken.value === ')') {\n                checkToken = extra.tokens[extra.openParenToken - 1];\n                if (checkToken &&\n                        checkToken.type === 'Keyword' &&\n                        (checkToken.value === 'if' ||\n                         checkToken.value === 'while' ||\n                         checkToken.value === 'for' ||\n                         checkToken.value === 'with')) {\n                    return collectRegex();\n                }\n                return scanPunctuator();\n            }\n            if (prevToken.value === '}') {\n                // Dividing a function by anything makes little sense,\n                // but we have to check for that.\n                if (extra.tokens[extra.openCurlyToken - 3] &&\n                        extra.tokens[extra.openCurlyToken - 3].type === 'Keyword') {\n                    // Anonymous function.\n                    checkToken = extra.tokens[extra.openCurlyToken - 4];\n                    if (!checkToken) {\n                        return scanPunctuator();\n                    }\n                } else if (extra.tokens[extra.openCurlyToken - 4] &&\n                        extra.tokens[extra.openCurlyToken - 4].type === 'Keyword') {\n                    // Named function.\n                    checkToken = extra.tokens[extra.openCurlyToken - 5];\n                    if (!checkToken) {\n                        return collectRegex();\n                    }\n                } else {\n                    return scanPunctuator();\n                }\n                // checkToken determines whether the function is\n                // a declaration or an expression.\n                if (FnExprTokens.indexOf(checkToken.value) >= 0) {\n                    // It is an expression.\n                    return scanPunctuator();\n                }\n                // It is a declaration.\n                return collectRegex();\n            }\n            return collectRegex();\n        }\n        if (prevToken.type === 'Keyword') {\n            return collectRegex();\n        }\n        return scanPunctuator();\n    }\n\n    function advance() {\n        var ch;\n\n        skipComment();\n\n        if (index >= length) {\n            return {\n                type: Token.EOF,\n                lineNumber: lineNumber,\n                lineStart: lineStart,\n                range: [index, index]\n            };\n        }\n\n        ch = source.charCodeAt(index);\n\n        // Very common: ( and ) and ;\n        if (ch === 40 || ch === 41 || ch === 58) {\n            return scanPunctuator();\n        }\n\n        // String literal starts with single quote (#39) or double quote (#34).\n        if (ch === 39 || ch === 34) {\n            return scanStringLiteral();\n        }\n\n        if (isIdentifierStart(ch)) {\n            return scanIdentifier();\n        }\n\n        // Dot (.) char #46 can also start a floating-point number, hence the need\n        // to check the next character.\n        if (ch === 46) {\n            if (isDecimalDigit(source.charCodeAt(index + 1))) {\n                return scanNumericLiteral();\n            }\n            return scanPunctuator();\n        }\n\n        if (isDecimalDigit(ch)) {\n            return scanNumericLiteral();\n        }\n\n        // Slash (/) char #47 can also start a regex.\n        if (extra.tokenize && ch === 47) {\n            return advanceSlash();\n        }\n\n        return scanPunctuator();\n    }\n\n    function collectToken() {\n        var start, loc, token, range, value;\n\n        skipComment();\n        start = index;\n        loc = {\n            start: {\n                line: lineNumber,\n                column: index - lineStart\n            }\n        };\n\n        token = advance();\n        loc.end = {\n            line: lineNumber,\n            column: index - lineStart\n        };\n\n        if (token.type !== Token.EOF) {\n            range = [token.range[0], token.range[1]];\n            value = source.slice(token.range[0], token.range[1]);\n            extra.tokens.push({\n                type: TokenName[token.type],\n                value: value,\n                range: range,\n                loc: loc\n            });\n        }\n\n        return token;\n    }\n\n    function lex() {\n        var token;\n\n        token = lookahead;\n        index = token.range[1];\n        lineNumber = token.lineNumber;\n        lineStart = token.lineStart;\n\n        lookahead = (typeof extra.tokens !== 'undefined') ? collectToken() : advance();\n\n        index = token.range[1];\n        lineNumber = token.lineNumber;\n        lineStart = token.lineStart;\n\n        return token;\n    }\n\n    function peek() {\n        var pos, line, start;\n\n        pos = index;\n        line = lineNumber;\n        start = lineStart;\n        lookahead = (typeof extra.tokens !== 'undefined') ? collectToken() : advance();\n        index = pos;\n        lineNumber = line;\n        lineStart = start;\n    }\n\n    SyntaxTreeDelegate = {\n\n        name: 'SyntaxTree',\n\n        markStart: function () {\n            if (extra.loc) {\n                state.markerStack.push(index - lineStart);\n                state.markerStack.push(lineNumber);\n            }\n            if (extra.range) {\n                state.markerStack.push(index);\n            }\n        },\n\n        markEnd: function (node) {\n            if (extra.range) {\n                node.range = [state.markerStack.pop(), index];\n            }\n            if (extra.loc) {\n                node.loc = {\n                    start: {\n                        line: state.markerStack.pop(),\n                        column: state.markerStack.pop()\n                    },\n                    end: {\n                        line: lineNumber,\n                        column: index - lineStart\n                    }\n                };\n                this.postProcess(node);\n            }\n            return node;\n        },\n\n        markEndIf: function (node) {\n            if (node.range || node.loc) {\n                if (extra.loc) {\n                    state.markerStack.pop();\n                    state.markerStack.pop();\n                }\n                if (extra.range) {\n                    state.markerStack.pop();\n                }\n            } else {\n                this.markEnd(node);\n            }\n            return node;\n        },\n\n        postProcess: function (node) {\n            if (extra.source) {\n                node.loc.source = extra.source;\n            }\n            return node;\n        },\n\n        createArrayExpression: function (elements) {\n            return {\n                type: Syntax.ArrayExpression,\n                elements: elements\n            };\n        },\n\n        createAssignmentExpression: function (operator, left, right) {\n            return {\n                type: Syntax.AssignmentExpression,\n                operator: operator,\n                left: left,\n                right: right\n            };\n        },\n\n        createBinaryExpression: function (operator, left, right) {\n            var type = (operator === '||' || operator === '&&') ? Syntax.LogicalExpression :\n                        Syntax.BinaryExpression;\n            return {\n                type: type,\n                operator: operator,\n                left: left,\n                right: right\n            };\n        },\n\n        createBlockStatement: function (body) {\n            return {\n                type: Syntax.BlockStatement,\n                body: body\n            };\n        },\n\n        createBreakStatement: function (label) {\n            return {\n                type: Syntax.BreakStatement,\n                label: label\n            };\n        },\n\n        createCallExpression: function (callee, args) {\n            return {\n                type: Syntax.CallExpression,\n                callee: callee,\n                'arguments': args\n            };\n        },\n\n        createCatchClause: function (param, body) {\n            return {\n                type: Syntax.CatchClause,\n                param: param,\n                body: body\n            };\n        },\n\n        createConditionalExpression: function (test, consequent, alternate) {\n            return {\n                type: Syntax.ConditionalExpression,\n                test: test,\n                consequent: consequent,\n                alternate: alternate\n            };\n        },\n\n        createContinueStatement: function (label) {\n            return {\n                type: Syntax.ContinueStatement,\n                label: label\n            };\n        },\n\n        createDebuggerStatement: function () {\n            return {\n                type: Syntax.DebuggerStatement\n            };\n        },\n\n        createDoWhileStatement: function (body, test) {\n            return {\n                type: Syntax.DoWhileStatement,\n                body: body,\n                test: test\n            };\n        },\n\n        createEmptyStatement: function () {\n            return {\n                type: Syntax.EmptyStatement\n            };\n        },\n\n        createExpressionStatement: function (expression) {\n            return {\n                type: Syntax.ExpressionStatement,\n                expression: expression\n            };\n        },\n\n        createForStatement: function (init, test, update, body) {\n            return {\n                type: Syntax.ForStatement,\n                init: init,\n                test: test,\n                update: update,\n                body: body\n            };\n        },\n\n        createForInStatement: function (left, right, body) {\n            return {\n                type: Syntax.ForInStatement,\n                left: left,\n                right: right,\n                body: body,\n                each: false\n            };\n        },\n\n        createFunctionDeclaration: function (id, params, defaults, body) {\n            return {\n                type: Syntax.FunctionDeclaration,\n                id: id,\n                params: params,\n                defaults: defaults,\n                body: body,\n                rest: null,\n                generator: false,\n                expression: false\n            };\n        },\n\n        createFunctionExpression: function (id, params, defaults, body) {\n            return {\n                type: Syntax.FunctionExpression,\n                id: id,\n                params: params,\n                defaults: defaults,\n                body: body,\n                rest: null,\n                generator: false,\n                expression: false\n            };\n        },\n\n        createIdentifier: function (name) {\n            return {\n                type: Syntax.Identifier,\n                name: name\n            };\n        },\n\n        createIfStatement: function (test, consequent, alternate) {\n            return {\n                type: Syntax.IfStatement,\n                test: test,\n                consequent: consequent,\n                alternate: alternate\n            };\n        },\n\n        createLabeledStatement: function (label, body) {\n            return {\n                type: Syntax.LabeledStatement,\n                label: label,\n                body: body\n            };\n        },\n\n        createLiteral: function (token) {\n            return {\n                type: Syntax.Literal,\n                value: token.value,\n                raw: source.slice(token.range[0], token.range[1])\n            };\n        },\n\n        createMemberExpression: function (accessor, object, property) {\n            return {\n                type: Syntax.MemberExpression,\n                computed: accessor === '[',\n                object: object,\n                property: property\n            };\n        },\n\n        createNewExpression: function (callee, args) {\n            return {\n                type: Syntax.NewExpression,\n                callee: callee,\n                'arguments': args\n            };\n        },\n\n        createObjectExpression: function (properties) {\n            return {\n                type: Syntax.ObjectExpression,\n                properties: properties\n            };\n        },\n\n        createPostfixExpression: function (operator, argument) {\n            return {\n                type: Syntax.UpdateExpression,\n                operator: operator,\n                argument: argument,\n                prefix: false\n            };\n        },\n\n        createProgram: function (body) {\n            return {\n                type: Syntax.Program,\n                body: body\n            };\n        },\n\n        createProperty: function (kind, key, value) {\n            return {\n                type: Syntax.Property,\n                key: key,\n                value: value,\n                kind: kind\n            };\n        },\n\n        createReturnStatement: function (argument) {\n            return {\n                type: Syntax.ReturnStatement,\n                argument: argument\n            };\n        },\n\n        createSequenceExpression: function (expressions) {\n            return {\n                type: Syntax.SequenceExpression,\n                expressions: expressions\n            };\n        },\n\n        createSwitchCase: function (test, consequent) {\n            return {\n                type: Syntax.SwitchCase,\n                test: test,\n                consequent: consequent\n            };\n        },\n\n        createSwitchStatement: function (discriminant, cases) {\n            return {\n                type: Syntax.SwitchStatement,\n                discriminant: discriminant,\n                cases: cases\n            };\n        },\n\n        createThisExpression: function () {\n            return {\n                type: Syntax.ThisExpression\n            };\n        },\n\n        createThrowStatement: function (argument) {\n            return {\n                type: Syntax.ThrowStatement,\n                argument: argument\n            };\n        },\n\n        createTryStatement: function (block, guardedHandlers, handlers, finalizer) {\n            return {\n                type: Syntax.TryStatement,\n                block: block,\n                guardedHandlers: guardedHandlers,\n                handlers: handlers,\n                finalizer: finalizer\n            };\n        },\n\n        createUnaryExpression: function (operator, argument) {\n            if (operator === '++' || operator === '--') {\n                return {\n                    type: Syntax.UpdateExpression,\n                    operator: operator,\n                    argument: argument,\n                    prefix: true\n                };\n            }\n            return {\n                type: Syntax.UnaryExpression,\n                operator: operator,\n                argument: argument,\n                prefix: true\n            };\n        },\n\n        createVariableDeclaration: function (declarations, kind) {\n            return {\n                type: Syntax.VariableDeclaration,\n                declarations: declarations,\n                kind: kind\n            };\n        },\n\n        createVariableDeclarator: function (id, init) {\n            return {\n                type: Syntax.VariableDeclarator,\n                id: id,\n                init: init\n            };\n        },\n\n        createWhileStatement: function (test, body) {\n            return {\n                type: Syntax.WhileStatement,\n                test: test,\n                body: body\n            };\n        },\n\n        createWithStatement: function (object, body) {\n            return {\n                type: Syntax.WithStatement,\n                object: object,\n                body: body\n            };\n        }\n    };\n\n    // Return true if there is a line terminator before the next token.\n\n    function peekLineTerminator() {\n        var pos, line, start, found;\n\n        pos = index;\n        line = lineNumber;\n        start = lineStart;\n        skipComment();\n        found = lineNumber !== line;\n        index = pos;\n        lineNumber = line;\n        lineStart = start;\n\n        return found;\n    }\n\n    // Throw an exception\n\n    function throwError(token, messageFormat) {\n        var error,\n            args = Array.prototype.slice.call(arguments, 2),\n            msg = messageFormat.replace(\n                /%(\\d)/g,\n                function (whole, index) {\n                    assert(index < args.length, 'Message reference must be in range');\n                    return args[index];\n                }\n            );\n\n        if (typeof token.lineNumber === 'number') {\n            error = new Error('Line ' + token.lineNumber + ': ' + msg);\n            error.index = token.range[0];\n            error.lineNumber = token.lineNumber;\n            error.column = token.range[0] - lineStart + 1;\n        } else {\n            error = new Error('Line ' + lineNumber + ': ' + msg);\n            error.index = index;\n            error.lineNumber = lineNumber;\n            error.column = index - lineStart + 1;\n        }\n\n        error.description = msg;\n        throw error;\n    }\n\n    function throwErrorTolerant() {\n        try {\n            throwError.apply(null, arguments);\n        } catch (e) {\n            if (extra.errors) {\n                extra.errors.push(e);\n            } else {\n                throw e;\n            }\n        }\n    }\n\n\n    // Throw an exception because of the token.\n\n    function throwUnexpected(token) {\n        if (token.type === Token.EOF) {\n            throwError(token, Messages.UnexpectedEOS);\n        }\n\n        if (token.type === Token.NumericLiteral) {\n            throwError(token, Messages.UnexpectedNumber);\n        }\n\n        if (token.type === Token.StringLiteral) {\n            throwError(token, Messages.UnexpectedString);\n        }\n\n        if (token.type === Token.Identifier) {\n            throwError(token, Messages.UnexpectedIdentifier);\n        }\n\n        if (token.type === Token.Keyword) {\n            if (isFutureReservedWord(token.value)) {\n                throwError(token, Messages.UnexpectedReserved);\n            } else if (strict && isStrictModeReservedWord(token.value)) {\n                throwErrorTolerant(token, Messages.StrictReservedWord);\n                return;\n            }\n            throwError(token, Messages.UnexpectedToken, token.value);\n        }\n\n        // BooleanLiteral, NullLiteral, or Punctuator.\n        throwError(token, Messages.UnexpectedToken, token.value);\n    }\n\n    // Expect the next token to match the specified punctuator.\n    // If not, an exception will be thrown.\n\n    function expect(value) {\n        var token = lex();\n        if (token.type !== Token.Punctuator || token.value !== value) {\n            throwUnexpected(token);\n        }\n    }\n\n    // Expect the next token to match the specified keyword.\n    // If not, an exception will be thrown.\n\n    function expectKeyword(keyword) {\n        var token = lex();\n        if (token.type !== Token.Keyword || token.value !== keyword) {\n            throwUnexpected(token);\n        }\n    }\n\n    // Return true if the next token matches the specified punctuator.\n\n    function match(value) {\n        return lookahead.type === Token.Punctuator && lookahead.value === value;\n    }\n\n    // Return true if the next token matches the specified keyword\n\n    function matchKeyword(keyword) {\n        return lookahead.type === Token.Keyword && lookahead.value === keyword;\n    }\n\n    // Return true if the next token is an assignment operator\n\n    function matchAssign() {\n        var op;\n\n        if (lookahead.type !== Token.Punctuator) {\n            return false;\n        }\n        op = lookahead.value;\n        return op === '=' ||\n            op === '*=' ||\n            op === '/=' ||\n            op === '%=' ||\n            op === '+=' ||\n            op === '-=' ||\n            op === '<<=' ||\n            op === '>>=' ||\n            op === '>>>=' ||\n            op === '&=' ||\n            op === '^=' ||\n            op === '|=';\n    }\n\n    function consumeSemicolon() {\n        var line;\n\n        // Catch the very common case first: immediately a semicolon (char #59).\n        if (source.charCodeAt(index) === 59) {\n            lex();\n            return;\n        }\n\n        line = lineNumber;\n        skipComment();\n        if (lineNumber !== line) {\n            return;\n        }\n\n        if (match(';')) {\n            lex();\n            return;\n        }\n\n        if (lookahead.type !== Token.EOF && !match('}')) {\n            throwUnexpected(lookahead);\n        }\n    }\n\n    // Return true if provided expression is LeftHandSideExpression\n\n    function isLeftHandSide(expr) {\n        return expr.type === Syntax.Identifier || expr.type === Syntax.MemberExpression;\n    }\n\n    // 11.1.4 Array Initialiser\n\n    function parseArrayInitialiser() {\n        var elements = [];\n\n        expect('[');\n\n        while (!match(']')) {\n            if (match(',')) {\n                lex();\n                elements.push(null);\n            } else {\n                elements.push(parseAssignmentExpression());\n\n                if (!match(']')) {\n                    expect(',');\n                }\n            }\n        }\n\n        expect(']');\n\n        return delegate.createArrayExpression(elements);\n    }\n\n    // 11.1.5 Object Initialiser\n\n    function parsePropertyFunction(param, first) {\n        var previousStrict, body;\n\n        previousStrict = strict;\n        skipComment();\n        delegate.markStart();\n        body = parseFunctionSourceElements();\n        if (first && strict && isRestrictedWord(param[0].name)) {\n            throwErrorTolerant(first, Messages.StrictParamName);\n        }\n        strict = previousStrict;\n        return delegate.markEnd(delegate.createFunctionExpression(null, param, [], body));\n    }\n\n    function parseObjectPropertyKey() {\n        var token;\n\n        skipComment();\n        delegate.markStart();\n        token = lex();\n\n        // Note: This function is called only from parseObjectProperty(), where\n        // EOF and Punctuator tokens are already filtered out.\n\n        if (token.type === Token.StringLiteral || token.type === Token.NumericLiteral) {\n            if (strict && token.octal) {\n                throwErrorTolerant(token, Messages.StrictOctalLiteral);\n            }\n            return delegate.markEnd(delegate.createLiteral(token));\n        }\n\n        return delegate.markEnd(delegate.createIdentifier(token.value));\n    }\n\n    function parseObjectProperty() {\n        var token, key, id, value, param;\n\n        token = lookahead;\n        skipComment();\n        delegate.markStart();\n\n        if (token.type === Token.Identifier) {\n\n            id = parseObjectPropertyKey();\n\n            // Property Assignment: Getter and Setter.\n\n            if (token.value === 'get' && !match(':')) {\n                key = parseObjectPropertyKey();\n                expect('(');\n                expect(')');\n                value = parsePropertyFunction([]);\n                return delegate.markEnd(delegate.createProperty('get', key, value));\n            }\n            if (token.value === 'set' && !match(':')) {\n                key = parseObjectPropertyKey();\n                expect('(');\n                token = lookahead;\n                if (token.type !== Token.Identifier) {\n                    expect(')');\n                    throwErrorTolerant(token, Messages.UnexpectedToken, token.value);\n                    value = parsePropertyFunction([]);\n                } else {\n                    param = [ parseVariableIdentifier() ];\n                    expect(')');\n                    value = parsePropertyFunction(param, token);\n                }\n                return delegate.markEnd(delegate.createProperty('set', key, value));\n            }\n            expect(':');\n            value = parseAssignmentExpression();\n            return delegate.markEnd(delegate.createProperty('init', id, value));\n        }\n        if (token.type === Token.EOF || token.type === Token.Punctuator) {\n            throwUnexpected(token);\n        } else {\n            key = parseObjectPropertyKey();\n            expect(':');\n            value = parseAssignmentExpression();\n            return delegate.markEnd(delegate.createProperty('init', key, value));\n        }\n    }\n\n    function parseObjectInitialiser() {\n        var properties = [], property, name, key, kind, map = {}, toString = String;\n\n        expect('{');\n\n        while (!match('}')) {\n            property = parseObjectProperty();\n\n            if (property.key.type === Syntax.Identifier) {\n                name = property.key.name;\n            } else {\n                name = toString(property.key.value);\n            }\n            kind = (property.kind === 'init') ? PropertyKind.Data : (property.kind === 'get') ? PropertyKind.Get : PropertyKind.Set;\n\n            key = '$' + name;\n            if (Object.prototype.hasOwnProperty.call(map, key)) {\n                if (map[key] === PropertyKind.Data) {\n                    if (strict && kind === PropertyKind.Data) {\n                        throwErrorTolerant({}, Messages.StrictDuplicateProperty);\n                    } else if (kind !== PropertyKind.Data) {\n                        throwErrorTolerant({}, Messages.AccessorDataProperty);\n                    }\n                } else {\n                    if (kind === PropertyKind.Data) {\n                        throwErrorTolerant({}, Messages.AccessorDataProperty);\n                    } else if (map[key] & kind) {\n                        throwErrorTolerant({}, Messages.AccessorGetSet);\n                    }\n                }\n                map[key] |= kind;\n            } else {\n                map[key] = kind;\n            }\n\n            properties.push(property);\n\n            if (!match('}')) {\n                expect(',');\n            }\n        }\n\n        expect('}');\n\n        return delegate.createObjectExpression(properties);\n    }\n\n    // 11.1.6 The Grouping Operator\n\n    function parseGroupExpression() {\n        var expr;\n\n        expect('(');\n\n        expr = parseExpression();\n\n        expect(')');\n\n        return expr;\n    }\n\n\n    // 11.1 Primary Expressions\n\n    function parsePrimaryExpression() {\n        var type, token, expr;\n\n        if (match('(')) {\n            return parseGroupExpression();\n        }\n\n        type = lookahead.type;\n        delegate.markStart();\n\n        if (type === Token.Identifier) {\n            expr =  delegate.createIdentifier(lex().value);\n        } else if (type === Token.StringLiteral || type === Token.NumericLiteral) {\n            if (strict && lookahead.octal) {\n                throwErrorTolerant(lookahead, Messages.StrictOctalLiteral);\n            }\n            expr = delegate.createLiteral(lex());\n        } else if (type === Token.Keyword) {\n            if (matchKeyword('this')) {\n                lex();\n                expr = delegate.createThisExpression();\n            } else if (matchKeyword('function')) {\n                expr = parseFunctionExpression();\n            }\n        } else if (type === Token.BooleanLiteral) {\n            token = lex();\n            token.value = (token.value === 'true');\n            expr = delegate.createLiteral(token);\n        } else if (type === Token.NullLiteral) {\n            token = lex();\n            token.value = null;\n            expr = delegate.createLiteral(token);\n        } else if (match('[')) {\n            expr = parseArrayInitialiser();\n        } else if (match('{')) {\n            expr = parseObjectInitialiser();\n        } else if (match('/') || match('/=')) {\n            if (typeof extra.tokens !== 'undefined') {\n                expr = delegate.createLiteral(collectRegex());\n            } else {\n                expr = delegate.createLiteral(scanRegExp());\n            }\n        }\n\n        if (expr) {\n            return delegate.markEnd(expr);\n        }\n\n        throwUnexpected(lex());\n    }\n\n    // 11.2 Left-Hand-Side Expressions\n\n    function parseArguments() {\n        var args = [];\n\n        expect('(');\n\n        if (!match(')')) {\n            while (index < length) {\n                args.push(parseAssignmentExpression());\n                if (match(')')) {\n                    break;\n                }\n                expect(',');\n            }\n        }\n\n        expect(')');\n\n        return args;\n    }\n\n    function parseNonComputedProperty() {\n        var token;\n\n        delegate.markStart();\n        token = lex();\n\n        if (!isIdentifierName(token)) {\n            throwUnexpected(token);\n        }\n\n        return delegate.markEnd(delegate.createIdentifier(token.value));\n    }\n\n    function parseNonComputedMember() {\n        expect('.');\n\n        return parseNonComputedProperty();\n    }\n\n    function parseComputedMember() {\n        var expr;\n\n        expect('[');\n\n        expr = parseExpression();\n\n        expect(']');\n\n        return expr;\n    }\n\n    function parseNewExpression() {\n        var callee, args;\n\n        delegate.markStart();\n        expectKeyword('new');\n        callee = parseLeftHandSideExpression();\n        args = match('(') ? parseArguments() : [];\n\n        return delegate.markEnd(delegate.createNewExpression(callee, args));\n    }\n\n    function parseLeftHandSideExpressionAllowCall() {\n        var marker, expr, args, property;\n\n        marker = createLocationMarker();\n\n        expr = matchKeyword('new') ? parseNewExpression() : parsePrimaryExpression();\n\n        while (match('.') || match('[') || match('(')) {\n            if (match('(')) {\n                args = parseArguments();\n                expr = delegate.createCallExpression(expr, args);\n            } else if (match('[')) {\n                property = parseComputedMember();\n                expr = delegate.createMemberExpression('[', expr, property);\n            } else {\n                property = parseNonComputedMember();\n                expr = delegate.createMemberExpression('.', expr, property);\n            }\n            if (marker) {\n                marker.end();\n                marker.apply(expr);\n            }\n        }\n\n        return expr;\n    }\n\n    function parseLeftHandSideExpression() {\n        var marker, expr, property;\n\n        marker = createLocationMarker();\n\n        expr = matchKeyword('new') ? parseNewExpression() : parsePrimaryExpression();\n\n        while (match('.') || match('[')) {\n            if (match('[')) {\n                property = parseComputedMember();\n                expr = delegate.createMemberExpression('[', expr, property);\n            } else {\n                property = parseNonComputedMember();\n                expr = delegate.createMemberExpression('.', expr, property);\n            }\n            if (marker) {\n                marker.end();\n                marker.apply(expr);\n            }\n        }\n\n        return expr;\n    }\n\n    // 11.3 Postfix Expressions\n\n    function parsePostfixExpression() {\n        var expr, token;\n\n        delegate.markStart();\n        expr = parseLeftHandSideExpressionAllowCall();\n\n        if (lookahead.type === Token.Punctuator) {\n            if ((match('++') || match('--')) && !peekLineTerminator()) {\n                // 11.3.1, 11.3.2\n                if (strict && expr.type === Syntax.Identifier && isRestrictedWord(expr.name)) {\n                    throwErrorTolerant({}, Messages.StrictLHSPostfix);\n                }\n\n                if (!isLeftHandSide(expr)) {\n                    throwError({}, Messages.InvalidLHSInAssignment);\n                }\n\n                token = lex();\n                expr = delegate.createPostfixExpression(token.value, expr);\n            }\n        }\n\n        return delegate.markEndIf(expr);\n    }\n\n    // 11.4 Unary Operators\n\n    function parseUnaryExpression() {\n        var token, expr;\n\n        delegate.markStart();\n\n        if (lookahead.type !== Token.Punctuator && lookahead.type !== Token.Keyword) {\n            expr = parsePostfixExpression();\n        } else if (match('++') || match('--')) {\n            token = lex();\n            expr = parseUnaryExpression();\n            // 11.4.4, 11.4.5\n            if (strict && expr.type === Syntax.Identifier && isRestrictedWord(expr.name)) {\n                throwErrorTolerant({}, Messages.StrictLHSPrefix);\n            }\n\n            if (!isLeftHandSide(expr)) {\n                throwError({}, Messages.InvalidLHSInAssignment);\n            }\n\n            expr = delegate.createUnaryExpression(token.value, expr);\n        } else if (match('+') || match('-') || match('~') || match('!')) {\n            token = lex();\n            expr = parseUnaryExpression();\n            expr = delegate.createUnaryExpression(token.value, expr);\n        } else if (matchKeyword('delete') || matchKeyword('void') || matchKeyword('typeof')) {\n            token = lex();\n            expr = parseUnaryExpression();\n            expr = delegate.createUnaryExpression(token.value, expr);\n            if (strict && expr.operator === 'delete' && expr.argument.type === Syntax.Identifier) {\n                throwErrorTolerant({}, Messages.StrictDelete);\n            }\n        } else {\n            expr = parsePostfixExpression();\n        }\n\n        return delegate.markEndIf(expr);\n    }\n\n    function binaryPrecedence(token, allowIn) {\n        var prec = 0;\n\n        if (token.type !== Token.Punctuator && token.type !== Token.Keyword) {\n            return 0;\n        }\n\n        switch (token.value) {\n        case '||':\n            prec = 1;\n            break;\n\n        case '&&':\n            prec = 2;\n            break;\n\n        case '|':\n            prec = 3;\n            break;\n\n        case '^':\n            prec = 4;\n            break;\n\n        case '&':\n            prec = 5;\n            break;\n\n        case '==':\n        case '!=':\n        case '===':\n        case '!==':\n            prec = 6;\n            break;\n\n        case '<':\n        case '>':\n        case '<=':\n        case '>=':\n        case 'instanceof':\n            prec = 7;\n            break;\n\n        case 'in':\n            prec = allowIn ? 7 : 0;\n            break;\n\n        case '<<':\n        case '>>':\n        case '>>>':\n            prec = 8;\n            break;\n\n        case '+':\n        case '-':\n            prec = 9;\n            break;\n\n        case '*':\n        case '/':\n        case '%':\n            prec = 11;\n            break;\n\n        default:\n            break;\n        }\n\n        return prec;\n    }\n\n    // 11.5 Multiplicative Operators\n    // 11.6 Additive Operators\n    // 11.7 Bitwise Shift Operators\n    // 11.8 Relational Operators\n    // 11.9 Equality Operators\n    // 11.10 Binary Bitwise Operators\n    // 11.11 Binary Logical Operators\n\n    function parseBinaryExpression() {\n        var marker, markers, expr, token, prec, previousAllowIn, stack, right, operator, left, i;\n\n        previousAllowIn = state.allowIn;\n        state.allowIn = true;\n\n        marker = createLocationMarker();\n        left = parseUnaryExpression();\n\n        token = lookahead;\n        prec = binaryPrecedence(token, previousAllowIn);\n        if (prec === 0) {\n            return left;\n        }\n        token.prec = prec;\n        lex();\n\n        markers = [marker, createLocationMarker()];\n        right = parseUnaryExpression();\n\n        stack = [left, token, right];\n\n        while ((prec = binaryPrecedence(lookahead, previousAllowIn)) > 0) {\n\n            // Reduce: make a binary expression from the three topmost entries.\n            while ((stack.length > 2) && (prec <= stack[stack.length - 2].prec)) {\n                right = stack.pop();\n                operator = stack.pop().value;\n                left = stack.pop();\n                expr = delegate.createBinaryExpression(operator, left, right);\n                markers.pop();\n                marker = markers.pop();\n                if (marker) {\n                    marker.end();\n                    marker.apply(expr);\n                }\n                stack.push(expr);\n                markers.push(marker);\n            }\n\n            // Shift.\n            token = lex();\n            token.prec = prec;\n            stack.push(token);\n            markers.push(createLocationMarker());\n            expr = parseUnaryExpression();\n            stack.push(expr);\n        }\n\n        state.allowIn = previousAllowIn;\n\n        // Final reduce to clean-up the stack.\n        i = stack.length - 1;\n        expr = stack[i];\n        markers.pop();\n        while (i > 1) {\n            expr = delegate.createBinaryExpression(stack[i - 1].value, stack[i - 2], expr);\n            i -= 2;\n            marker = markers.pop();\n            if (marker) {\n                marker.end();\n                marker.apply(expr);\n            }\n        }\n\n        return expr;\n    }\n\n\n    // 11.12 Conditional Operator\n\n    function parseConditionalExpression() {\n        var expr, previousAllowIn, consequent, alternate;\n\n        delegate.markStart();\n        expr = parseBinaryExpression();\n\n        if (match('?')) {\n            lex();\n            previousAllowIn = state.allowIn;\n            state.allowIn = true;\n            consequent = parseAssignmentExpression();\n            state.allowIn = previousAllowIn;\n            expect(':');\n            alternate = parseAssignmentExpression();\n\n            expr = delegate.markEnd(delegate.createConditionalExpression(expr, consequent, alternate));\n        } else {\n            delegate.markEnd({});\n        }\n\n        return expr;\n    }\n\n    // 11.13 Assignment Operators\n\n    function parseAssignmentExpression() {\n        var token, left, right, node;\n\n        token = lookahead;\n        delegate.markStart();\n        node = left = parseConditionalExpression();\n\n        if (matchAssign()) {\n            // LeftHandSideExpression\n            if (!isLeftHandSide(left)) {\n                throwError({}, Messages.InvalidLHSInAssignment);\n            }\n\n            // 11.13.1\n            if (strict && left.type === Syntax.Identifier && isRestrictedWord(left.name)) {\n                throwErrorTolerant(token, Messages.StrictLHSAssignment);\n            }\n\n            token = lex();\n            right = parseAssignmentExpression();\n            node = delegate.createAssignmentExpression(token.value, left, right);\n        }\n\n        return delegate.markEndIf(node);\n    }\n\n    // 11.14 Comma Operator\n\n    function parseExpression() {\n        var expr;\n\n        delegate.markStart();\n        expr = parseAssignmentExpression();\n\n        if (match(',')) {\n            expr = delegate.createSequenceExpression([ expr ]);\n\n            while (index < length) {\n                if (!match(',')) {\n                    break;\n                }\n                lex();\n                expr.expressions.push(parseAssignmentExpression());\n            }\n        }\n\n        return delegate.markEndIf(expr);\n    }\n\n    // 12.1 Block\n\n    function parseStatementList() {\n        var list = [],\n            statement;\n\n        while (index < length) {\n            if (match('}')) {\n                break;\n            }\n            statement = parseSourceElement();\n            if (typeof statement === 'undefined') {\n                break;\n            }\n            list.push(statement);\n        }\n\n        return list;\n    }\n\n    function parseBlock() {\n        var block;\n\n        skipComment();\n        delegate.markStart();\n        expect('{');\n\n        block = parseStatementList();\n\n        expect('}');\n\n        return delegate.markEnd(delegate.createBlockStatement(block));\n    }\n\n    // 12.2 Variable Statement\n\n    function parseVariableIdentifier() {\n        var token;\n\n        skipComment();\n        delegate.markStart();\n        token = lex();\n\n        if (token.type !== Token.Identifier) {\n            throwUnexpected(token);\n        }\n\n        return delegate.markEnd(delegate.createIdentifier(token.value));\n    }\n\n    function parseVariableDeclaration(kind) {\n        var init = null, id;\n\n        skipComment();\n        delegate.markStart();\n        id = parseVariableIdentifier();\n\n        // 12.2.1\n        if (strict && isRestrictedWord(id.name)) {\n            throwErrorTolerant({}, Messages.StrictVarName);\n        }\n\n        if (kind === 'const') {\n            expect('=');\n            init = parseAssignmentExpression();\n        } else if (match('=')) {\n            lex();\n            init = parseAssignmentExpression();\n        }\n\n        return delegate.markEnd(delegate.createVariableDeclarator(id, init));\n    }\n\n    function parseVariableDeclarationList(kind) {\n        var list = [];\n\n        do {\n            list.push(parseVariableDeclaration(kind));\n            if (!match(',')) {\n                break;\n            }\n            lex();\n        } while (index < length);\n\n        return list;\n    }\n\n    function parseVariableStatement() {\n        var declarations;\n\n        expectKeyword('var');\n\n        declarations = parseVariableDeclarationList();\n\n        consumeSemicolon();\n\n        return delegate.createVariableDeclaration(declarations, 'var');\n    }\n\n    // kind may be `const` or `let`\n    // Both are experimental and not in the specification yet.\n    // see http://wiki.ecmascript.org/doku.php?id=harmony:const\n    // and http://wiki.ecmascript.org/doku.php?id=harmony:let\n    function parseConstLetDeclaration(kind) {\n        var declarations;\n\n        skipComment();\n        delegate.markStart();\n\n        expectKeyword(kind);\n\n        declarations = parseVariableDeclarationList(kind);\n\n        consumeSemicolon();\n\n        return delegate.markEnd(delegate.createVariableDeclaration(declarations, kind));\n    }\n\n    // 12.3 Empty Statement\n\n    function parseEmptyStatement() {\n        expect(';');\n        return delegate.createEmptyStatement();\n    }\n\n    // 12.4 Expression Statement\n\n    function parseExpressionStatement() {\n        var expr = parseExpression();\n        consumeSemicolon();\n        return delegate.createExpressionStatement(expr);\n    }\n\n    // 12.5 If statement\n\n    function parseIfStatement() {\n        var test, consequent, alternate;\n\n        expectKeyword('if');\n\n        expect('(');\n\n        test = parseExpression();\n\n        expect(')');\n\n        consequent = parseStatement();\n\n        if (matchKeyword('else')) {\n            lex();\n            alternate = parseStatement();\n        } else {\n            alternate = null;\n        }\n\n        return delegate.createIfStatement(test, consequent, alternate);\n    }\n\n    // 12.6 Iteration Statements\n\n    function parseDoWhileStatement() {\n        var body, test, oldInIteration;\n\n        expectKeyword('do');\n\n        oldInIteration = state.inIteration;\n        state.inIteration = true;\n\n        body = parseStatement();\n\n        state.inIteration = oldInIteration;\n\n        expectKeyword('while');\n\n        expect('(');\n\n        test = parseExpression();\n\n        expect(')');\n\n        if (match(';')) {\n            lex();\n        }\n\n        return delegate.createDoWhileStatement(body, test);\n    }\n\n    function parseWhileStatement() {\n        var test, body, oldInIteration;\n\n        expectKeyword('while');\n\n        expect('(');\n\n        test = parseExpression();\n\n        expect(')');\n\n        oldInIteration = state.inIteration;\n        state.inIteration = true;\n\n        body = parseStatement();\n\n        state.inIteration = oldInIteration;\n\n        return delegate.createWhileStatement(test, body);\n    }\n\n    function parseForVariableDeclaration() {\n        var token, declarations;\n\n        delegate.markStart();\n        token = lex();\n        declarations = parseVariableDeclarationList();\n\n        return delegate.markEnd(delegate.createVariableDeclaration(declarations, token.value));\n    }\n\n    function parseForStatement() {\n        var init, test, update, left, right, body, oldInIteration;\n\n        init = test = update = null;\n\n        expectKeyword('for');\n\n        expect('(');\n\n        if (match(';')) {\n            lex();\n        } else {\n            if (matchKeyword('var') || matchKeyword('let')) {\n                state.allowIn = false;\n                init = parseForVariableDeclaration();\n                state.allowIn = true;\n\n                if (init.declarations.length === 1 && matchKeyword('in')) {\n                    lex();\n                    left = init;\n                    right = parseExpression();\n                    init = null;\n                }\n            } else {\n                state.allowIn = false;\n                init = parseExpression();\n                state.allowIn = true;\n\n                if (matchKeyword('in')) {\n                    // LeftHandSideExpression\n                    if (!isLeftHandSide(init)) {\n                        throwError({}, Messages.InvalidLHSInForIn);\n                    }\n\n                    lex();\n                    left = init;\n                    right = parseExpression();\n                    init = null;\n                }\n            }\n\n            if (typeof left === 'undefined') {\n                expect(';');\n            }\n        }\n\n        if (typeof left === 'undefined') {\n\n            if (!match(';')) {\n                test = parseExpression();\n            }\n            expect(';');\n\n            if (!match(')')) {\n                update = parseExpression();\n            }\n        }\n\n        expect(')');\n\n        oldInIteration = state.inIteration;\n        state.inIteration = true;\n\n        body = parseStatement();\n\n        state.inIteration = oldInIteration;\n\n        return (typeof left === 'undefined') ?\n                delegate.createForStatement(init, test, update, body) :\n                delegate.createForInStatement(left, right, body);\n    }\n\n    // 12.7 The continue statement\n\n    function parseContinueStatement() {\n        var label = null, key;\n\n        expectKeyword('continue');\n\n        // Optimize the most common form: 'continue;'.\n        if (source.charCodeAt(index) === 59) {\n            lex();\n\n            if (!state.inIteration) {\n                throwError({}, Messages.IllegalContinue);\n            }\n\n            return delegate.createContinueStatement(null);\n        }\n\n        if (peekLineTerminator()) {\n            if (!state.inIteration) {\n                throwError({}, Messages.IllegalContinue);\n            }\n\n            return delegate.createContinueStatement(null);\n        }\n\n        if (lookahead.type === Token.Identifier) {\n            label = parseVariableIdentifier();\n\n            key = '$' + label.name;\n            if (!Object.prototype.hasOwnProperty.call(state.labelSet, key)) {\n                throwError({}, Messages.UnknownLabel, label.name);\n            }\n        }\n\n        consumeSemicolon();\n\n        if (label === null && !state.inIteration) {\n            throwError({}, Messages.IllegalContinue);\n        }\n\n        return delegate.createContinueStatement(label);\n    }\n\n    // 12.8 The break statement\n\n    function parseBreakStatement() {\n        var label = null, key;\n\n        expectKeyword('break');\n\n        // Catch the very common case first: immediately a semicolon (char #59).\n        if (source.charCodeAt(index) === 59) {\n            lex();\n\n            if (!(state.inIteration || state.inSwitch)) {\n                throwError({}, Messages.IllegalBreak);\n            }\n\n            return delegate.createBreakStatement(null);\n        }\n\n        if (peekLineTerminator()) {\n            if (!(state.inIteration || state.inSwitch)) {\n                throwError({}, Messages.IllegalBreak);\n            }\n\n            return delegate.createBreakStatement(null);\n        }\n\n        if (lookahead.type === Token.Identifier) {\n            label = parseVariableIdentifier();\n\n            key = '$' + label.name;\n            if (!Object.prototype.hasOwnProperty.call(state.labelSet, key)) {\n                throwError({}, Messages.UnknownLabel, label.name);\n            }\n        }\n\n        consumeSemicolon();\n\n        if (label === null && !(state.inIteration || state.inSwitch)) {\n            throwError({}, Messages.IllegalBreak);\n        }\n\n        return delegate.createBreakStatement(label);\n    }\n\n    // 12.9 The return statement\n\n    function parseReturnStatement() {\n        var argument = null;\n\n        expectKeyword('return');\n\n        if (!state.inFunctionBody) {\n            throwErrorTolerant({}, Messages.IllegalReturn);\n        }\n\n        // 'return' followed by a space and an identifier is very common.\n        if (source.charCodeAt(index) === 32) {\n            if (isIdentifierStart(source.charCodeAt(index + 1))) {\n                argument = parseExpression();\n                consumeSemicolon();\n                return delegate.createReturnStatement(argument);\n            }\n        }\n\n        if (peekLineTerminator()) {\n            return delegate.createReturnStatement(null);\n        }\n\n        if (!match(';')) {\n            if (!match('}') && lookahead.type !== Token.EOF) {\n                argument = parseExpression();\n            }\n        }\n\n        consumeSemicolon();\n\n        return delegate.createReturnStatement(argument);\n    }\n\n    // 12.10 The with statement\n\n    function parseWithStatement() {\n        var object, body;\n\n        if (strict) {\n            throwErrorTolerant({}, Messages.StrictModeWith);\n        }\n\n        expectKeyword('with');\n\n        expect('(');\n\n        object = parseExpression();\n\n        expect(')');\n\n        body = parseStatement();\n\n        return delegate.createWithStatement(object, body);\n    }\n\n    // 12.10 The swith statement\n\n    function parseSwitchCase() {\n        var test,\n            consequent = [],\n            statement;\n\n        skipComment();\n        delegate.markStart();\n        if (matchKeyword('default')) {\n            lex();\n            test = null;\n        } else {\n            expectKeyword('case');\n            test = parseExpression();\n        }\n        expect(':');\n\n        while (index < length) {\n            if (match('}') || matchKeyword('default') || matchKeyword('case')) {\n                break;\n            }\n            statement = parseStatement();\n            consequent.push(statement);\n        }\n\n        return delegate.markEnd(delegate.createSwitchCase(test, consequent));\n    }\n\n    function parseSwitchStatement() {\n        var discriminant, cases, clause, oldInSwitch, defaultFound;\n\n        expectKeyword('switch');\n\n        expect('(');\n\n        discriminant = parseExpression();\n\n        expect(')');\n\n        expect('{');\n\n        if (match('}')) {\n            lex();\n            return delegate.createSwitchStatement(discriminant);\n        }\n\n        cases = [];\n\n        oldInSwitch = state.inSwitch;\n        state.inSwitch = true;\n        defaultFound = false;\n\n        while (index < length) {\n            if (match('}')) {\n                break;\n            }\n            clause = parseSwitchCase();\n            if (clause.test === null) {\n                if (defaultFound) {\n                    throwError({}, Messages.MultipleDefaultsInSwitch);\n                }\n                defaultFound = true;\n            }\n            cases.push(clause);\n        }\n\n        state.inSwitch = oldInSwitch;\n\n        expect('}');\n\n        return delegate.createSwitchStatement(discriminant, cases);\n    }\n\n    // 12.13 The throw statement\n\n    function parseThrowStatement() {\n        var argument;\n\n        expectKeyword('throw');\n\n        if (peekLineTerminator()) {\n            throwError({}, Messages.NewlineAfterThrow);\n        }\n\n        argument = parseExpression();\n\n        consumeSemicolon();\n\n        return delegate.createThrowStatement(argument);\n    }\n\n    // 12.14 The try statement\n\n    function parseCatchClause() {\n        var param, body;\n\n        skipComment();\n        delegate.markStart();\n        expectKeyword('catch');\n\n        expect('(');\n        if (match(')')) {\n            throwUnexpected(lookahead);\n        }\n\n        param = parseVariableIdentifier();\n        // 12.14.1\n        if (strict && isRestrictedWord(param.name)) {\n            throwErrorTolerant({}, Messages.StrictCatchVariable);\n        }\n\n        expect(')');\n        body = parseBlock();\n        return delegate.markEnd(delegate.createCatchClause(param, body));\n    }\n\n    function parseTryStatement() {\n        var block, handlers = [], finalizer = null;\n\n        expectKeyword('try');\n\n        block = parseBlock();\n\n        if (matchKeyword('catch')) {\n            handlers.push(parseCatchClause());\n        }\n\n        if (matchKeyword('finally')) {\n            lex();\n            finalizer = parseBlock();\n        }\n\n        if (handlers.length === 0 && !finalizer) {\n            throwError({}, Messages.NoCatchOrFinally);\n        }\n\n        return delegate.createTryStatement(block, [], handlers, finalizer);\n    }\n\n    // 12.15 The debugger statement\n\n    function parseDebuggerStatement() {\n        expectKeyword('debugger');\n\n        consumeSemicolon();\n\n        return delegate.createDebuggerStatement();\n    }\n\n    // 12 Statements\n\n    function parseStatement() {\n        var type = lookahead.type,\n            expr,\n            labeledBody,\n            key;\n\n        if (type === Token.EOF) {\n            throwUnexpected(lookahead);\n        }\n\n        skipComment();\n        delegate.markStart();\n\n        if (type === Token.Punctuator) {\n            switch (lookahead.value) {\n            case ';':\n                return delegate.markEnd(parseEmptyStatement());\n            case '{':\n                return delegate.markEnd(parseBlock());\n            case '(':\n                return delegate.markEnd(parseExpressionStatement());\n            default:\n                break;\n            }\n        }\n\n        if (type === Token.Keyword) {\n            switch (lookahead.value) {\n            case 'break':\n                return delegate.markEnd(parseBreakStatement());\n            case 'continue':\n                return delegate.markEnd(parseContinueStatement());\n            case 'debugger':\n                return delegate.markEnd(parseDebuggerStatement());\n            case 'do':\n                return delegate.markEnd(parseDoWhileStatement());\n            case 'for':\n                return delegate.markEnd(parseForStatement());\n            case 'function':\n                return delegate.markEnd(parseFunctionDeclaration());\n            case 'if':\n                return delegate.markEnd(parseIfStatement());\n            case 'return':\n                return delegate.markEnd(parseReturnStatement());\n            case 'switch':\n                return delegate.markEnd(parseSwitchStatement());\n            case 'throw':\n                return delegate.markEnd(parseThrowStatement());\n            case 'try':\n                return delegate.markEnd(parseTryStatement());\n            case 'var':\n                return delegate.markEnd(parseVariableStatement());\n            case 'while':\n                return delegate.markEnd(parseWhileStatement());\n            case 'with':\n                return delegate.markEnd(parseWithStatement());\n            default:\n                break;\n            }\n        }\n\n        expr = parseExpression();\n\n        // 12.12 Labelled Statements\n        if ((expr.type === Syntax.Identifier) && match(':')) {\n            lex();\n\n            key = '$' + expr.name;\n            if (Object.prototype.hasOwnProperty.call(state.labelSet, key)) {\n                throwError({}, Messages.Redeclaration, 'Label', expr.name);\n            }\n\n            state.labelSet[key] = true;\n            labeledBody = parseStatement();\n            delete state.labelSet[key];\n            return delegate.markEnd(delegate.createLabeledStatement(expr, labeledBody));\n        }\n\n        consumeSemicolon();\n\n        return delegate.markEnd(delegate.createExpressionStatement(expr));\n    }\n\n    // 13 Function Definition\n\n    function parseFunctionSourceElements() {\n        var sourceElement, sourceElements = [], token, directive, firstRestricted,\n            oldLabelSet, oldInIteration, oldInSwitch, oldInFunctionBody;\n\n        skipComment();\n        delegate.markStart();\n        expect('{');\n\n        while (index < length) {\n            if (lookahead.type !== Token.StringLiteral) {\n                break;\n            }\n            token = lookahead;\n\n            sourceElement = parseSourceElement();\n            sourceElements.push(sourceElement);\n            if (sourceElement.expression.type !== Syntax.Literal) {\n                // this is not directive\n                break;\n            }\n            directive = source.slice(token.range[0] + 1, token.range[1] - 1);\n            if (directive === 'use strict') {\n                strict = true;\n                if (firstRestricted) {\n                    throwErrorTolerant(firstRestricted, Messages.StrictOctalLiteral);\n                }\n            } else {\n                if (!firstRestricted && token.octal) {\n                    firstRestricted = token;\n                }\n            }\n        }\n\n        oldLabelSet = state.labelSet;\n        oldInIteration = state.inIteration;\n        oldInSwitch = state.inSwitch;\n        oldInFunctionBody = state.inFunctionBody;\n\n        state.labelSet = {};\n        state.inIteration = false;\n        state.inSwitch = false;\n        state.inFunctionBody = true;\n\n        while (index < length) {\n            if (match('}')) {\n                break;\n            }\n            sourceElement = parseSourceElement();\n            if (typeof sourceElement === 'undefined') {\n                break;\n            }\n            sourceElements.push(sourceElement);\n        }\n\n        expect('}');\n\n        state.labelSet = oldLabelSet;\n        state.inIteration = oldInIteration;\n        state.inSwitch = oldInSwitch;\n        state.inFunctionBody = oldInFunctionBody;\n\n        return delegate.markEnd(delegate.createBlockStatement(sourceElements));\n    }\n\n    function parseParams(firstRestricted) {\n        var param, params = [], token, stricted, paramSet, key, message;\n        expect('(');\n\n        if (!match(')')) {\n            paramSet = {};\n            while (index < length) {\n                token = lookahead;\n                param = parseVariableIdentifier();\n                key = '$' + token.value;\n                if (strict) {\n                    if (isRestrictedWord(token.value)) {\n                        stricted = token;\n                        message = Messages.StrictParamName;\n                    }\n                    if (Object.prototype.hasOwnProperty.call(paramSet, key)) {\n                        stricted = token;\n                        message = Messages.StrictParamDupe;\n                    }\n                } else if (!firstRestricted) {\n                    if (isRestrictedWord(token.value)) {\n                        firstRestricted = token;\n                        message = Messages.StrictParamName;\n                    } else if (isStrictModeReservedWord(token.value)) {\n                        firstRestricted = token;\n                        message = Messages.StrictReservedWord;\n                    } else if (Object.prototype.hasOwnProperty.call(paramSet, key)) {\n                        firstRestricted = token;\n                        message = Messages.StrictParamDupe;\n                    }\n                }\n                params.push(param);\n                paramSet[key] = true;\n                if (match(')')) {\n                    break;\n                }\n                expect(',');\n            }\n        }\n\n        expect(')');\n\n        return {\n            params: params,\n            stricted: stricted,\n            firstRestricted: firstRestricted,\n            message: message\n        };\n    }\n\n    function parseFunctionDeclaration() {\n        var id, params = [], body, token, stricted, tmp, firstRestricted, message, previousStrict;\n\n        skipComment();\n        delegate.markStart();\n\n        expectKeyword('function');\n        token = lookahead;\n        id = parseVariableIdentifier();\n        if (strict) {\n            if (isRestrictedWord(token.value)) {\n                throwErrorTolerant(token, Messages.StrictFunctionName);\n            }\n        } else {\n            if (isRestrictedWord(token.value)) {\n                firstRestricted = token;\n                message = Messages.StrictFunctionName;\n            } else if (isStrictModeReservedWord(token.value)) {\n                firstRestricted = token;\n                message = Messages.StrictReservedWord;\n            }\n        }\n\n        tmp = parseParams(firstRestricted);\n        params = tmp.params;\n        stricted = tmp.stricted;\n        firstRestricted = tmp.firstRestricted;\n        if (tmp.message) {\n            message = tmp.message;\n        }\n\n        previousStrict = strict;\n        body = parseFunctionSourceElements();\n        if (strict && firstRestricted) {\n            throwError(firstRestricted, message);\n        }\n        if (strict && stricted) {\n            throwErrorTolerant(stricted, message);\n        }\n        strict = previousStrict;\n\n        return delegate.markEnd(delegate.createFunctionDeclaration(id, params, [], body));\n    }\n\n    function parseFunctionExpression() {\n        var token, id = null, stricted, firstRestricted, message, tmp, params = [], body, previousStrict;\n\n        delegate.markStart();\n        expectKeyword('function');\n\n        if (!match('(')) {\n            token = lookahead;\n            id = parseVariableIdentifier();\n            if (strict) {\n                if (isRestrictedWord(token.value)) {\n                    throwErrorTolerant(token, Messages.StrictFunctionName);\n                }\n            } else {\n                if (isRestrictedWord(token.value)) {\n                    firstRestricted = token;\n                    message = Messages.StrictFunctionName;\n                } else if (isStrictModeReservedWord(token.value)) {\n                    firstRestricted = token;\n                    message = Messages.StrictReservedWord;\n                }\n            }\n        }\n\n        tmp = parseParams(firstRestricted);\n        params = tmp.params;\n        stricted = tmp.stricted;\n        firstRestricted = tmp.firstRestricted;\n        if (tmp.message) {\n            message = tmp.message;\n        }\n\n        previousStrict = strict;\n        body = parseFunctionSourceElements();\n        if (strict && firstRestricted) {\n            throwError(firstRestricted, message);\n        }\n        if (strict && stricted) {\n            throwErrorTolerant(stricted, message);\n        }\n        strict = previousStrict;\n\n        return delegate.markEnd(delegate.createFunctionExpression(id, params, [], body));\n    }\n\n    // 14 Program\n\n    function parseSourceElement() {\n        if (lookahead.type === Token.Keyword) {\n            switch (lookahead.value) {\n            case 'const':\n            case 'let':\n                return parseConstLetDeclaration(lookahead.value);\n            case 'function':\n                return parseFunctionDeclaration();\n            default:\n                return parseStatement();\n            }\n        }\n\n        if (lookahead.type !== Token.EOF) {\n            return parseStatement();\n        }\n    }\n\n    function parseSourceElements() {\n        var sourceElement, sourceElements = [], token, directive, firstRestricted;\n\n        while (index < length) {\n            token = lookahead;\n            if (token.type !== Token.StringLiteral) {\n                break;\n            }\n\n            sourceElement = parseSourceElement();\n            sourceElements.push(sourceElement);\n            if (sourceElement.expression.type !== Syntax.Literal) {\n                // this is not directive\n                break;\n            }\n            directive = source.slice(token.range[0] + 1, token.range[1] - 1);\n            if (directive === 'use strict') {\n                strict = true;\n                if (firstRestricted) {\n                    throwErrorTolerant(firstRestricted, Messages.StrictOctalLiteral);\n                }\n            } else {\n                if (!firstRestricted && token.octal) {\n                    firstRestricted = token;\n                }\n            }\n        }\n\n        while (index < length) {\n            sourceElement = parseSourceElement();\n            if (typeof sourceElement === 'undefined') {\n                break;\n            }\n            sourceElements.push(sourceElement);\n        }\n        return sourceElements;\n    }\n\n    function parseProgram() {\n        var body;\n\n        skipComment();\n        delegate.markStart();\n        strict = false;\n        peek();\n        body = parseSourceElements();\n        return delegate.markEnd(delegate.createProgram(body));\n    }\n\n    function filterTokenLocation() {\n        var i, entry, token, tokens = [];\n\n        for (i = 0; i < extra.tokens.length; ++i) {\n            entry = extra.tokens[i];\n            token = {\n                type: entry.type,\n                value: entry.value\n            };\n            if (extra.range) {\n                token.range = entry.range;\n            }\n            if (extra.loc) {\n                token.loc = entry.loc;\n            }\n            tokens.push(token);\n        }\n\n        extra.tokens = tokens;\n    }\n\n    function LocationMarker() {\n        this.marker = [index, lineNumber, index - lineStart, 0, 0, 0];\n    }\n\n    LocationMarker.prototype = {\n        constructor: LocationMarker,\n\n        end: function () {\n            this.marker[3] = index;\n            this.marker[4] = lineNumber;\n            this.marker[5] = index - lineStart;\n        },\n\n        apply: function (node) {\n            if (extra.range) {\n                node.range = [this.marker[0], this.marker[3]];\n            }\n            if (extra.loc) {\n                node.loc = {\n                    start: {\n                        line: this.marker[1],\n                        column: this.marker[2]\n                    },\n                    end: {\n                        line: this.marker[4],\n                        column: this.marker[5]\n                    }\n                };\n            }\n            node = delegate.postProcess(node);\n        }\n    };\n\n    function createLocationMarker() {\n        if (!extra.loc && !extra.range) {\n            return null;\n        }\n\n        skipComment();\n\n        return new LocationMarker();\n    }\n\n    function tokenize(code, options) {\n        var toString,\n            token,\n            tokens;\n\n        toString = String;\n        if (typeof code !== 'string' && !(code instanceof String)) {\n            code = toString(code);\n        }\n\n        delegate = SyntaxTreeDelegate;\n        source = code;\n        index = 0;\n        lineNumber = (source.length > 0) ? 1 : 0;\n        lineStart = 0;\n        length = source.length;\n        lookahead = null;\n        state = {\n            allowIn: true,\n            labelSet: {},\n            inFunctionBody: false,\n            inIteration: false,\n            inSwitch: false,\n            lastCommentStart: -1,\n        };\n\n        extra = {};\n\n        // Options matching.\n        options = options || {};\n\n        // Of course we collect tokens here.\n        options.tokens = true;\n        extra.tokens = [];\n        extra.tokenize = true;\n        // The following two fields are necessary to compute the Regex tokens.\n        extra.openParenToken = -1;\n        extra.openCurlyToken = -1;\n\n        extra.range = (typeof options.range === 'boolean') && options.range;\n        extra.loc = (typeof options.loc === 'boolean') && options.loc;\n\n        if (typeof options.comment === 'boolean' && options.comment) {\n            extra.comments = [];\n        }\n        if (typeof options.tolerant === 'boolean' && options.tolerant) {\n            extra.errors = [];\n        }\n\n        if (length > 0) {\n            if (typeof source[0] === 'undefined') {\n                // Try first to convert to a string. This is good as fast path\n                // for old IE which understands string indexing for string\n                // literals only and not for string object.\n                if (code instanceof String) {\n                    source = code.valueOf();\n                }\n            }\n        }\n\n        try {\n            peek();\n            if (lookahead.type === Token.EOF) {\n                return extra.tokens;\n            }\n\n            token = lex();\n            while (lookahead.type !== Token.EOF) {\n                try {\n                    token = lex();\n                } catch (lexError) {\n                    token = lookahead;\n                    if (extra.errors) {\n                        extra.errors.push(lexError);\n                        // We have to break on the first error\n                        // to avoid infinite loops.\n                        break;\n                    } else {\n                        throw lexError;\n                    }\n                }\n            }\n\n            filterTokenLocation();\n            tokens = extra.tokens;\n            if (typeof extra.comments !== 'undefined') {\n                tokens.comments = extra.comments;\n            }\n            if (typeof extra.errors !== 'undefined') {\n                tokens.errors = extra.errors;\n            }\n        } catch (e) {\n            throw e;\n        } finally {\n            extra = {};\n        }\n        return tokens;\n    }\n\n    function parse(code, options) {\n        var program, toString;\n\n        toString = String;\n        if (typeof code !== 'string' && !(code instanceof String)) {\n            code = toString(code);\n        }\n\n        delegate = SyntaxTreeDelegate;\n        source = code;\n        index = 0;\n        lineNumber = (source.length > 0) ? 1 : 0;\n        lineStart = 0;\n        length = source.length;\n        lookahead = null;\n        state = {\n            allowIn: true,\n            labelSet: {},\n            inFunctionBody: false,\n            inIteration: false,\n            inSwitch: false,\n            lastCommentStart: -1,\n            markerStack: []\n        };\n\n        extra = {};\n        if (typeof options !== 'undefined') {\n            extra.range = (typeof options.range === 'boolean') && options.range;\n            extra.loc = (typeof options.loc === 'boolean') && options.loc;\n\n            if (extra.loc && options.source !== null && options.source !== undefined) {\n                extra.source = toString(options.source);\n            }\n\n            if (typeof options.tokens === 'boolean' && options.tokens) {\n                extra.tokens = [];\n            }\n            if (typeof options.comment === 'boolean' && options.comment) {\n                extra.comments = [];\n            }\n            if (typeof options.tolerant === 'boolean' && options.tolerant) {\n                extra.errors = [];\n            }\n        }\n\n        if (length > 0) {\n            if (typeof source[0] === 'undefined') {\n                // Try first to convert to a string. This is good as fast path\n                // for old IE which understands string indexing for string\n                // literals only and not for string object.\n                if (code instanceof String) {\n                    source = code.valueOf();\n                }\n            }\n        }\n\n        try {\n            program = parseProgram();\n            if (typeof extra.comments !== 'undefined') {\n                program.comments = extra.comments;\n            }\n            if (typeof extra.tokens !== 'undefined') {\n                filterTokenLocation();\n                program.tokens = extra.tokens;\n            }\n            if (typeof extra.errors !== 'undefined') {\n                program.errors = extra.errors;\n            }\n        } catch (e) {\n            throw e;\n        } finally {\n            extra = {};\n        }\n\n        return program;\n    }\n\n    // Sync with package.json and component.json.\n    exports.version = '1.1.0-dev';\n\n    exports.tokenize = tokenize;\n\n    exports.parse = parse;\n\n    // Deep copy.\n    exports.Syntax = (function () {\n        var name, types = {};\n\n        if (typeof Object.create === 'function') {\n            types = Object.create(null);\n        }\n\n        for (name in Syntax) {\n            if (Syntax.hasOwnProperty(name)) {\n                types[name] = Syntax[name];\n            }\n        }\n\n        if (typeof Object.freeze === 'function') {\n            Object.freeze(types);\n        }\n\n        return types;\n    }());\n\n}));\n/* vim: set sw=4 ts=4 et tw=80 : */"}